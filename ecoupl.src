C XX XXX 13 - LB - IMPLEMENTATION AND DEVELOPMENT
C
C*MODULE CTRANS  *DECK PRGREN
      SUBROUTINE PRGREN(VEC,NUMB,VECTYP,NUMBF)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER METHOD, PARTI, DONOR, ACCEPT, NUMBF, NUMB
      LOGICAL CGREEN, PNBO, GFDYNA, VIRTNO, SCANDA,PATHWY
      PARAMETER(NUMMO0=2000, NUMM20=NUMMO0*NUMMO0)
      PARAMETER (MXATM=3000, MXAO=8192)
 
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /GREENS/ SVEC, ORBVEC, EVEC, FOCKV, OLVEC, TRAN
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /GFPAR / CGREEN,PNBO,GFDYNA,VIRTNO,SCANDA,PATHWY,HEFF96,
     *                LMOPTH
      COMMON /GREEVD/ NVECS(8)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /PRPOPT/ ETOLLZ,ILOCAL
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)

      DOUBLE PRECISION ELECCOU
      DOUBLE PRECISION VEC(NUMB)
      DIMENSION SVEC(NUMM20), ORBVEC(NUMM20), OLVEC(NUMM20)
      DIMENSION EVEC(NUMMO0), FOCKV(NUMM20)
      DIMENSION TRAN(NUMM20)
      DOUBLE PRECISION ETUN
 
C     ------------------------------------------------------------
 
C     SAVES ARRAYS AS CALCULATED: VECTYP:
C         1 = S MATRIX (OVERLAP), WRITTEN AS VECTOR SVEC
C         2 = MO'S (EIGENECTORS, ORBITAL COEFFICIENTS), AS VECTOR ORBVEC
C         3 = E'S (EIGENVALUES, ORBITAL ENERGIES), AS VECTOR EVEC
C         4 = LOCALIZED MOLECULAR ORBITALS FOR OCCUPIED ORBITALS
C         5 = GAMESS FOCK MATRIX IN ( AO BASIS SET ?)
C         6 = PFNBO FROM NBO
C         7 = SFNBO FROM NBO
C         8 = TRANSFORMATION MATRIX FROM LOCALIZATION
 
C     ------------------------------------------------------------
 
C TEST IF EXCEEDS MAXIMUM NUMBER OF BASIS FUNCTIONS
      IF (NUM.GT.NUMMO0) THEN
         WRITE(IW,*)'ERROR: THIS NUMBER OF BFS EXCEEDS THE MAXIMUM:'
         WRITE(IW,*)'THE GREENS FUNCTION CALCULATION FAILED.'
         GO TO 330
      ENDIF
 
C     SAVING REQUIRED ARRAYS FOR GF CALCULATION

C     OVERLAP VECTORS FROM INT.SRC OR MPCINT.SRC

      IF (VECTYP.EQ.1) THEN
         NSVECDIM=NUMB
         DO 331 I=1,NUMB
            SVEC(I)=VEC(I)
  331    CONTINUE
         NVECS(1)=1
      ENDIF

C     MOLECULAR ORBITAL VECTORS FROM RHFUHF.SRC

      IF (VECTYP.EQ.2) THEN
         NORBVDIM=NUMB
         DO 332 I=1,NORBVDIM
             ORBVEC(I)=VEC(I)
  332    CONTINUE
         NVECS(2)=1
      ENDIF

C     ORBITAL ENERGY VECTOR FROM RHFUHF.SRC

      IF (VECTYP.EQ.3) THEN
         NEVECDIM=NUMB
         DO 333 I=1,NEVECDIM
             EVEC(I)=VEC(I)
  333    CONTINUE
         NVECS(3)=1
      ENDIF
 
C     LOCALIZED OCCUPIED ORBITALS, IF CALCULATED FROM LOCAL.SRC

      IF (VECTYP.EQ.4) THEN
         NLOCVDIM=NUMB
         DO 353 I=1,NLOCVDIM
C            SAVE AS NEW VECTOR, OLVEC
             OLVEC(I)=VEC(I)
  353    CONTINUE
         NVECS(4)=1
      ENDIF

C    FOCK MATRIX FROM RHFUHF.SRC

      IF (VECTYP.EQ.5) THEN
         NFOCKDIM=(NUMBF*NUMBF)/2+(NUMBF/2)
         DO 363 I=1,NFOCKDIM
             FOCKV(I)=VEC(I)
  363    CONTINUE
         NVECS(5)=1
      ENDIF

C     PNBO FOCK MATRIX, IF NBO CALCULATION, FROM GMSNBO.SRC

      IF (VECTYP.EQ.6) THEN
         NFOCKDIM=NUMBF*NUMBF
         DO 364 I=1,NFOCKDIM
             FOCKV(I)=VEC(I)
  364    CONTINUE
         NVECS(6)=1
      ENDIF

C     PNBO OVERLAP MATRIX, IF NBO CALCULATION, FROM GMSNBO.SRC

      IF (VECTYP.EQ.7) THEN
         NSVECDIM=NUMBF*NUMBF
         DO 365 I=1,NSVECDIM
             SVEC(I)=VEC(I)
  365    CONTINUE
         NVECS(7)=1
      ENDIF

C     TRANSFORMATION MATRIX, FROM BOYS LOCALIZATION

      IF (VECTYP.EQ.8) THEN
         NTRANDIM=NUMBF*NUMBF
         DO 366 I=1,NTRANDIM
             TRAN(I)=VEC(I)
  366    CONTINUE
         NVECS(8)=1
      CALL PRSQ12(TRAN,NUMBF,NUMBF,NUMBF)
      ENDIF


C     CONDITIONS TO CALL ELECTRON TRANSFER CALCULATION
 
      IF(NVECS(1).EQ.1.AND.NVECS(2).EQ.1.AND.NVECS(3).EQ.1
     *.AND.NVECS(5).EQ.1) THEN
C          IF LOCALIZING, DO NOT CALL UNTIL LOCALIZATION AT END
           IF(ILOCAL.EQ.1.OR.ILOCAL.EQ.2.OR.ILOCAL.EQ.3) THEN
               IF(VECTYP.NE.4) GOTO 330
           ENDIF
           IF(PNBO) THEN
             IF(NVECS(6).NE.1.OR.NVECS(7).NE.1) GOTO 330
             WRITE(IW,*)'CT CALCULATION CALLED WITH PNBO'
           ENDIF


      IF(SCANDA) THEN
          NDAMAT=NA-NOUTA
          CALL DASCAN(NUMBF,NOUTA,NDAMAT)
      ELSE
          CALL GREENF(NUMBF,NOUTA,0,0,ELECCOU)
      ENDIF

      ENDIF
 
  330 CONTINUE
      RETURN
      END
 
 
C     ------------------------------------------------------------
C     ------------------------------------------------------------
 

C     SUBROUTINE CONTROLLING THE SCANNING THROUGH ALL D/A PAIRS
C*MODULE CTRANS  *DECK DASCAN
      SUBROUTINE DASCAN(NUMBF,NFROZ,NDAMAT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
  
C     STUFF FOR AUTOMATION OF D/A ORBITAL SEARCHES
      DIMENSION DAMATRIX(NDAMAT**2)
      PARAMETER (MXATM=3000)
      DOUBLE PRECISION ELECCOU

      LOGICAL CGREEN, PNBO,GFDYNA,VIRTNO,SCANDA, PATHWY
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)

C     START LOOP FOR SCANDA OPTION-- TO GO THROUGH ALL D/A
C     COMBINATIONS IN THE OCCUPIED SPACE

C     debugging inputs
      WRITE(IW,*)'IN DASCAN, NA', NA
      WRITE(IW,*)'IN DASCAN, NFROZ', NFROZ

C     INITIALIZE DONOR-ACCEPTOR MATRIX
        DO 780 I=1,NDAMAT
          DO 781 J=1,NDAMAT
             IJ=(J-1)*NDAMAT+I
             DAMATRIX(IJ)=0.0D0
 781      CONTINUE
 780    CONTINUE

      
C     SET RANGE FOR D-A SCAN
      NSCAN1=NFROZ+1
      NSCAN2=NA

C     START GIANT DO-LOOP FOR SCANNING THROUGH ALL D/A PAIRS
      DO 100 NSCANI=NSCAN1,NSCAN2
        DO 101 NSCANJ=NSCAN1,(NSCANI-1)
          ELECCOU=0.0D0
          CALL GREENF(NUMBF,NFROZ,NSCANI,NSCANJ,ELECCOU)
C         WRITE(IW,*)'BACK IN DASCAN, ELECCOU=',ELECCOU
C         I refers to acceptors, rows
C         J refers to donors, columns
          I=NSCANI-NFROZ
          J=NSCANJ-NFROZ
          IJ=(J-1)*NDAMAT+I
C         SAVE RESULT INTO DAMATRIX
          DAMATRIX(IJ)=ELECCOU
 101    CONTINUE
 100  CONTINUE

      CALL PRSQ16(DAMATRIX,NDAMAT,NDAMAT,NDAMAT,NFROZ)

      RETURN
      END

C     ------------------------------------------------------------
C     ------------------------------------------------------------
 
C     ELECTRONIC COUPLING / GREEN FUNCTION CALCULATION SUBROUTINE
C     USING ONE OF FOUR METHODS FOR GETTING ET PROPERTIES
C
C*MODULE CTRANS  *DECK GREENF
      SUBROUTINE GREENF(NUMBF,NFROZ,NSCANI,NSCANJ,ELECCOU)
      PARAMETER (MXATM=3000)
      PARAMETER (NUMMO0=2000, NUMM20=NUMMO0*NUMMO0)  

      IMPLICIT DOUBLE PRECISION(A-H,O-Z)

      DOUBLE PRECISION ELECCOU

      INTEGER INFO,I,J, NUMBF, NUMB
      INTEGER METHOD, PARTI, DONOR, ACCEPT,TTDIM,NTEMPD
 
C     ------------------------------------------------------------
C     DIMENSIONS IN COMMON BLOCKS
      DIMENSION SVEC(NUMM20), ORBVEC(NUMM20), OLVEC(NUMM20)
      DIMENSION EVEC(NUMMO0), FOCKV(NUMM20)
      DIMENSION FOCKLMO(NUMM20), SLMO(NUMM20)
C     ------------------------------------------------------------

      DIMENSION TRAN(NUMM20)
      DIMENSION ORBMAT(NUMBF,NUMBF)
      DIMENSION OVERMAT(NUMBF,NUMBF)

      DIMENSION WRK(8*NUMBF**2)
      DIMENSION FOCKM(NUMBF,NUMBF)

 
C    METHOD 4 COMPONENTS
C    HEFF VIA EQUATION 20 OF SKOURTIS 2006.
      DOUBLE PRECISION TERMONEV(2*(NUMBF-2))

      DIMENSION HPP06(2,2), HPQ06(2,NUMBF-2),HQP06(NUMBF-2,2) 
      DIMENSION HPQ06V(2*NUMBF-4),HQP06V(NUMBF*2-4) 
      DIMENSION HQQ06(NUMBF-2,NUMBF-2)
      DIMENSION HQQ06V((NUMBF-2)*(NUMBF-2))
      DIMENSION SPP06(2,2), SPQ06(2,NUMBF-2),SQP06(NUMBF-2,2)
      DIMENSION ESPQ06V(2*NUMBF-4),ESQP06V(2*NUMBF-4)
      DIMENSION SQQ06(NUMBF-2, NUMBF-2)
      DIMENSION ESQQ06V((NUMBF-2)*(NUMBF-2))
      DIMENSION TERMTWOV((NUMBF-2)*(NUMBF-2))
      DIMENSION TERM3V((NUMBF-2)*2)
      DIMENSION TEMPVEC1((NUMBF-2)*2), TEMPVEC2(4)
      DIMENSION HEFFPP(2,2)

C     DIAGONALIZATION OF HEFFPP 
      DIMENSION HEFFEIG(2), HEIGDIFF(2), HEFFEIGP(2)

C     STUFF FOR LOCALIZATION
      DIMENSION IPIV(NUMMO0)
      DIMENSION SPACE(3*NUMMO0)

      DIMENSION RUTSTOP(5)

      COMMON /GREENS/ SVEC, ORBVEC, EVEC, FOCKV, OLVEC, TRAN
      COMMON /GREEN2/ FOCKLMO,SLMO 
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PRPOPT/ ETOLLZ,ILOCAL
 
      COMMON /GFPAR2/ ETUN
      COMMON /GFPAR3/ METHOD, PARTI, DONOR, ACCEPT
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)

      DOUBLE PRECISION ETUN

      LOGICAL CGREEN, PNBO, GFDYNA, VIRTNO, SCANDA, PATHWY,HEFF96
      COMMON /GFPAR / CGREEN,PNBO,GFDYNA,VIRTNO,SCANDA,PATHWY,HEFF96,
     *                LMOPTH



C     ------------------------------------------------------------
C     CALCULATE GREEN FUNCTION MATRIX AND EFFECTIVE HAMILTONIAN
C     FROM OVERRAP MATRIX AND MOLECULAR ORBITAL COEFFICIENT MATRIX
C     (EIGENVECTORS) AND MOLECULAR ORBITAL ENERGIES (EIGENVALUES)
C     FORMULATION FROM I.V. KURNIKOV AND D. N. BERATAN
C     J. CHEM. PHYS. VOL 105, NO. 21. PAGE 9561 (1996)
C     ------------------------------------------------------------
      NUMMO=NA
      WRITE(IW,*)' START OF GREENF SUBROUTINE -- ET CALCULATION'
 
C     ------------------------------------------------------------
C     GENERAL SETUP FOR ALL METHODS 1-4
C     ------------------------------------------------------------
      WRITE(IW,*) NUMBF,'NUMBF=NUMBER OF BASIS FUNCTIONS in GREENF'

C     INITIALIZE ALL MATRICES
      DO 209 I=1,5
         RUTSTOP(I)=0.0D0
 209  CONTINUE 

      IJ=0
      DO 210 I=1,NUMBF
         DO 211 J=1,NUMBF
            IJ=(J-1)*NUMBF+I
            FOCKLMO(IJ)=0.0D0
C           SLMO(IJ)=0.0D0
            OVERMAT(I,J)=0.0D0
            FOCKM(I,J)=0.0D0
            ORBMAT(I,J)=0.0D0
            FOCKM(I,J)=0.0D0
 211     CONTINUE
 210  CONTINUE

      DO 215 I=1,(NUMBF-2)
         DO 216 J=1,(NUMBF-2)
            IJ=(J-1)*(NUMBF-2)+I
            HQQ06(I,J)=0.0D0
            SQQ06(I,J)=0.0D0
C           TERMTWO(I,J)=0.0D0
            TERMTWOV(IJ)=0.0D0
            HQQ06V(IJ)=0.0D0
            ESQQ06V(IJ)=0.0D0
 216     CONTINUE
 215  CONTINUE
      DO 217 I=1,2
         DO 218 J=1,2
            HEFFPP(I,J)=0.0D0
            HPP06(I,J)=0.0D0
            SPP06(I,J)=0.0D0
            IJ=(J-1)*2+I
            TEMPVEC2(IJ)=0.0D0
 218     CONTINUE
         DO 219 J=1,(NUMBF-2)
            JI=(I-1)*(NUMBF-2)+J
            IJ=(J-1)*2+I
            HPQ06(I,J)=0.0D0
            HPQ06V(IJ)=0.0D0
            HQP06(J,I)=0.0D0
            HQP06V(JI)=0.0D0
            SPQ06(I,J)=0.0D0
            ESPQ06V(IJ)=0.0D0
            SQP06(J,I)=0.0D0
            ESQP06V(JI)=0.0D0
            TERM3V(JI)=0.0D0
            TEMPVEC1(JI)=0.0D0
            TERMONEV(IJ)=0.0D0
 219     CONTINUE
 217  CONTINUE
      
      INUM=8*NUMBF
      DO 222 I=1,INUM
            WRK(I)=0.0D0
 222  CONTINUE



C=========================================================================
C       SET-UP FOR THE EFFECTIVE HAMILTONIAN CALCULATION
C=========================================================================
C     REALIZATION: REGARDLESS OF LOCALIZATION OR NOT, THE S,F MATRICES
C                  SHOULD BE IN THE MO BASIS ANYWAY, OTHERWISE THEIR
C                  INDICES DO NOT CORRESPOND TO THE MO CHOICE OF D/A
C                  THEREFORE THIS COULD BE WHY NBO CALCS WORK, AND NEARLY ALL
C                  GAMESS CALCULATIONS DON'T CONVERGE.

C     FOCK MATRIX IN AO BASIS
      CALL PRTRI1(FOCKV,NUMBF)

C     INITIALIZE FOCKLMO AND SLMO WITH AO BASIS VECTORS, IN CASE OF NO LOCALIZATION 
C     ALTHOUGH IT SHOUDL ALWAYS BE DONE WITH LOCALIZATION
      DO 456 I=1,NUMBF**2
         FOCKLMO(I)=FOCKV(I)
         SLMO(I)=SVEC(I)
 456  CONTINUE

     
      CALL PRTRI1(FOCKV,NUMBF)


C     TRANSFORM THE F,S MATRICES FROM AO TO MO BASIS
C     USING RELATIONSHIP   S(MO-BASIS)=C-DAGGER * S(AO-BASIS) * C
C     FOR C= CANONICAL MOLECULAR ORBITALS


      IF(ILOCAL.EQ.1.OR.ILOCAL.EQ.2.OR.ILOCAL.EQ.3) THEN

C      IF EXCLUDING THE VIRTUAL ORBITALS FROM THE CALCULATION
C      THEN SKIP TO SECTION TREATING THE ALTERED MATRIX DIMENSIONS

       IF(VIRTNO) GOTO 242

C       PRODUCE TRANSFORMED FOCK MATRIX
        CALL TFTRI(FOCKLMO,FOCKV,OLVEC,WRK,NUMBF,NUMBF,NUMBF)
        CALL PRTRI5(FOCKLMO,NUMBF)

C       PRODUCE TRANSFORMED OVERLAP MATRIX
        CALL TFTRI(SLMO,SVEC,OLVEC,WRK,NUMBF,NUMBF,NUMBF)
C       CALL PRTRI2(SLMO,NUMBF)


      ENDIF

C=========================================================================
C=========================================================================



C     CONVERT MO, S, FOCK VECTORS TO MATRICES
 
      IJ=0
C     CONVERT SYMMETRIC MATRICES FROM VECTORS, OVERLAP, FOCK
      DO 334 I=1,NUMBF
          DO 335 J=1,I-1
             IJ=IJ+1
             OVERMAT(I,J)=SLMO(IJ)
             OVERMAT(J,I)=SLMO(IJ)
             FOCKM(I,J)=FOCKLMO(IJ)
             FOCKM(J,I)=FOCKLMO(IJ)
 335      CONTINUE
C         FOR I = J, DIAGONAL ENTRIES
          IJ=IJ+1
          OVERMAT(I,I)=SLMO(IJ)
          FOCKM(I,I)=FOCKLMO(IJ)

C     CONVERT NONSYMMETRIC MATRICES FROM VECTORS: EIGENVECTORS
          IJ2=0
          NUMB=NUMBF
          DO 336 J=1,NUMB
             IJ2=(J-1)*NUMBF+I
           IF(ILOCAL.EQ.1.OR.ILOCAL.EQ.2.OR.ILOCAL.EQ.3) THEN
             ORBMAT(I,J)=OLVEC(IJ2)
           ELSE
             ORBMAT(I,J)=ORBVEC(IJ2)
           ENDIF
 336      CONTINUE
 334  CONTINUE



      IF(PNBO) THEN
C         OVERWRITE FOCK AND OVERLAP WITH FPNBO AND SPNBO FROM NBO PROGRAM
C         BECAUSE THEN OVERMAT AND FOCKM ARE NOT SYMMETRIC ANYMORE
          DO 111 I=1,NUMBF
          DO 112 J=1,NUMBF
             IJ2=(J-1)*NUMBF+I
             OVERMAT(I,J)=SVEC(IJ2)
             IF(IJ2.LE.10) WRITE(IW,*)SVEC(IJ2),'SPNBO '
             FOCKM(I,J)=FOCKV(IJ2)
             IF(IJ2.LE.10) WRITE(IW,*)FOCKV(IJ2),'FPNBO'
 112      CONTINUE
 111      CONTINUE
      ENDIF 


 242  CONTINUE

      IF(VIRTNO) THEN
 
C     transformation of F(LMO)= LMO-DAGGER*FAO*LMO
C     transformation of S(LMO)= LMO-DAGGER*SAO*LMO
        CALL TFTRI(FOCKLMO,FOCKV,OLVEC,WRK,NA,NUMBF,NUMBF)
        CALL TFTRI(SLMO,SVEC,OLVEC,WRK,NA,NUMBF,NUMBF)
C     check that these result in square matrices of dimension NA
        CALL PRTRI5(FOCKLMO,NA)
        CALL PRTRI2(SLMO,NA)

      IJ=0
C     CONVERT SYMMETRIC MATRICES FROM VECTORS, OVERLAP, FOCK
      DO 243 I=1,NA
          DO 244 J=1,I-1
             IJ=IJ+1
             OVERMAT(I,J)=SLMO(IJ)
             OVERMAT(J,I)=SLMO(IJ)
             FOCKM(I,J)=FOCKLMO(IJ)
             FOCKM(J,I)=FOCKLMO(IJ)
 244      CONTINUE
C         FOR I = J, DIAGONAL ENTRIES
          IJ=IJ+1
          OVERMAT(I,I)=SLMO(IJ)
          FOCKM(I,I)=FOCKLMO(IJ)

C     CONVERT NONSYMMETRIC MATRICES FROM VECTORS: EIGENVECTORS 
          IJ2=0
          DO 245 J=1,NA
             IJ2=(J-1)*NUMBF+I
             ORBMAT(I,J)=OLVEC(IJ2)
 245      CONTINUE
 243  CONTINUE

C     END OF VIRTNO SETUP
      ENDIF

C     ------------------------------------------------------------
C     CHANGE STARTING TUNNELING ENERGY PARAMETER TO AVERAGE OF
C     HOMO AND LUMO ENERGIES, IF NO ETUN KEYWORD ENTERED

C     IF (ETUN.EQ.3333) THEN
          ETUN=(EVEC(NUMMO)+EVEC(NUMMO+1))/2.0D0
          WRITE(IW,*)'CALCULATED HOMO-LUMO ENERGY AVERAGE FOR ETUN'
C      ENDIF

C     ------------------------------------------------------------
C 
C     END OF GENERAL SET-UP


C     TURNED OFF THIS IF-STATEMENT, TO ALWAYS RUN THE CONVERGENCE
C     OF THE TUNNELING ENERGY
C     IF(METHOD.EQ.4)THEN
C    ------------------------------------------------------
C
C                      METHOD 4
C          METHODOLOGY OF  SKOURTIS & TEKLOS 2006
C          CONDUCT EFFECTIVE HAMILTONIAN CALCULATION AS 
C          DESCRIBED BY SS SKOURTIS AND A TEKLOS,
C          J CHEM PHYS 125, 244103, 2006
C
C          USAGE OF LOCALIZED ORBITALS HIGHLY RECOMMENDED
C          OTHERWISE IT DOESN'T CONVERGE
C
C    ------------------------------------------------------

C     DONOR AND ACCEPTOR VALUES FOR IF SCANNING THROUGH ALL COMBINATIONS
      IF(SCANDA) THEN
          DONOR=NSCANJ
          ACCEPT=NSCANI
      ELSE
C     DEFAULTING TO HOMO-1=DONOR, HOMO=ACCEPT
C     IN THE CASE THAT THE USER DID NOT SPECIFY D AND A
          IF(DONOR.EQ.0) DONOR=NA-1
          IF(ACCEPT.EQ.0) ACCEPT=NA
C     IT MUST BE TRUE THAT ACCEPT>DONOR
C     TESTED THAT THIS IS A VALID EXCHANGE-- D-A COUPLING=A-D COUPLING
          IF(DONOR.NE.0.AND.DONOR.GT.ACCEPT) THEN
             NTEMPD=DONOR
             DONOR=ACCEPT
             ACCEPT=NTEMPD
          ENDIF
      ENDIF

C     IF EXCLUDING VIRTUAL SPACE..
      IF(VIRTNO) NUMBF=NA

C ------------------------------------------
C ------------------------------------------
C    IMPORTANT NOTE-- METHOD REQUIRES THE FOCK AND OVERLAP
C                     MATRICES TO BE LOCALIZED TO THE PREORTHOGONALIZED
C                     NATURAL BOND OBITAL BASIS (AS IN THE NBO PROGRAM)
C                     ...ULTIMATELY THIS SHOULD BE WRITTEN INTO THE CODE
C                     AS A REQUIREMENT AND NOT AN OPTION...(OR THAT NOT
C                     LOCALIZING SHOULD BE THE OPTION, AND THE DEFAULT TO
C                     ACTIVATE LOCALIZATION)
C ------------------------------------------
C ------------------------------------------

C     CALCULATING THE FOLLOWING:
C     HEFFPP(E)= HPP + (HPQ - E*SPQ)(E*SQQ - HQQ)^-1(HQP - E*SQP)
C DIMN  (2X2)   (2X2)    (2 X N-2)   (N-2 X N-2)     (N-2 X 2)

C     FIRST PARTITION THE FOCK MATRIX AND OVERLAP MATRICES
C          INTO HPP, HPQ, HQP, HQQ
C               SPP, SPQ, SQP, SQQ

C     PREPARE PP-PARTITION OF FOCK AND OVERLAPMATRICES
             HPP06(1,1)=FOCKM(DONOR,DONOR)
             HPP06(1,2)=FOCKM(DONOR,ACCEPT)
             HPP06(2,1)=FOCKM(ACCEPT,DONOR)
             HPP06(2,2)=FOCKM(ACCEPT,ACCEPT)
             SPP06(1,1)=OVERMAT(DONOR,DONOR)
             SPP06(1,2)=OVERMAT(DONOR,ACCEPT)
             SPP06(2,1)=OVERMAT(ACCEPT,DONOR)
             SPP06(2,2)=OVERMAT(ACCEPT,ACCEPT)

C TESTING WHY THIS IS EMPTY
      WRITE(IW,*)'HPP06 MATRIX='
      WRITE(IW,*)HPP06(1,1), HPP06(1,2)
      WRITE(IW,*)HPP06(2,1), HPP06(2,2)
      

C    PREPARE PQ- AND QP-PARTITIONS OF FOCK AND OVERLAP MATRICES
      DO 8160 I=1,NUMBF
         IF(I.LT.DONOR) THEN
             HPQ06(1,I)=FOCKM(DONOR,I)
             HPQ06(2,I)=FOCKM(ACCEPT,I)
             HQP06(I,1)=FOCKM(I,DONOR)
             HQP06(I,2)=FOCKM(I,ACCEPT)
             SPQ06(1,I)=OVERMAT(DONOR,I)
             SPQ06(2,I)=OVERMAT(ACCEPT,I)
             SQP06(I,1)=OVERMAT(I,DONOR)
             SQP06(I,2)=OVERMAT(I,ACCEPT)
         ELSEIF(I.GT.DONOR.AND.I.LT.ACCEPT) THEN
             HPQ06(1,I-1)=FOCKM(DONOR,I)
             HPQ06(2,I-1)=FOCKM(ACCEPT,I)
             HQP06(I-1,1)=FOCKM(I,DONOR)
             HQP06(I-1,2)=FOCKM(I,ACCEPT)
             SPQ06(1,I-1)=OVERMAT(DONOR,I)
             SPQ06(2,I-1)=OVERMAT(ACCEPT,I)
             SQP06(I-1,1)=OVERMAT(I,DONOR)
             SQP06(I-1,2)=OVERMAT(I,ACCEPT)
         ELSEIF(I.GT.ACCEPT) THEN
             HPQ06(1,I-2)=FOCKM(DONOR,I)
             HPQ06(2,I-2)=FOCKM(ACCEPT,I)
             HQP06(I-2,1)=FOCKM(I,DONOR)
             HQP06(I-2,2)=FOCKM(I,ACCEPT)
             SPQ06(1,I-2)=OVERMAT(DONOR,I)
             SPQ06(2,I-2)=OVERMAT(ACCEPT,I)
             SQP06(I-2,1)=OVERMAT(I,DONOR)
             SQP06(I-2,2)=OVERMAT(I,ACCEPT)
         ENDIF
 8160 CONTINUE

C     PREPARE QQ-PARTITION OF FOCK AND OVERLAP MATRICES
   
      DO 8161 I=1,(DONOR-1)
         DO 8164 J=1,NUMBF
           IF(J.LT.DONOR)THEN
              HQQ06(I,J)=FOCKM(I,J)
              SQQ06(I,J)=OVERMAT(I,J)
           ELSEIF(J.GT.DONOR.AND.J.LT.ACCEPT)THEN
              HQQ06(I,J-1)=FOCKM(I,J)
              SQQ06(I,J-1)=OVERMAT(I,J)
           ELSEIF(J.GT.ACCEPT)THEN
              HQQ06(I,J-2)=FOCKM(I,J)
              SQQ06(I,J-2)=OVERMAT(I,J)
           ENDIF
 8164    CONTINUE
 8161 CONTINUE

      DO 8162 I=(DONOR+1),(ACCEPT-1)
         DO 8165 J=1,NUMBF
           IF(J.LT.DONOR)THEN
              HQQ06(I-1,J)=FOCKM(I,J)
              SQQ06(I-1,J)=OVERMAT(I,J)
           ELSEIF(J.GT.DONOR.AND.J.LT.ACCEPT)THEN
              HQQ06(I-1,J-1)=FOCKM(I,J)
              SQQ06(I-1,J-1)=OVERMAT(I,J)
           ELSEIF(J.GT.ACCEPT)THEN
              HQQ06(I-1,J-2)=FOCKM(I,J)
              SQQ06(I-1,J-2)=OVERMAT(I,J)
           ENDIF
 8165    CONTINUE
 8162 CONTINUE

      DO 8163 I=(ACCEPT+1),NUMBF
         DO 8167 J=1,NUMBF
           IF(J.LT.DONOR)THEN
              HQQ06(I-2,J)=FOCKM(I,J)
              SQQ06(I-2,J)=OVERMAT(I,J)
           ELSEIF(J.GT.DONOR.AND.J.LT.ACCEPT)THEN
              HQQ06(I-2,J-1)=FOCKM(I,J)
              SQQ06(I-2,J-1)=OVERMAT(I,J)
           ELSEIF(J.GT.ACCEPT)THEN
              HQQ06(I-2,J-2)=FOCKM(I,J)
              SQQ06(I-2,J-2)=OVERMAT(I,J)
           ENDIF
 8167    CONTINUE
 8163 CONTINUE

C     -----------------------------------------------------
C     BEGINNING OF CYCLE TO CONVERGE EFFECTIVE HAMILTONIAN
C     -----------------------------------------------------
      M=0
      NEWETUN=0
C     INITIALIZE SCALARS BEFORE THE CONVERGENCE LOOP BEGINS
         HEIGDIFF(1)=1.0D+00
         HEIGDIFF(2)=1.0D+00
         HEFFEIGP(1)=0.0D+00
         HEFFEIGP(2)=0.0D+00

 8340 CONTINUE
 
C      THINGS TO INITIALIZE EACH ITERATION
       HEFFEIG(1)=0.0D+00
       HEFFEIG(2)=0.0D+00
       TRACE=0.0D+00
       DETER=0.0D+00
       CHECKER=0.0D+00


C     MATHEMATICS FOR:  (HPQ - E*SPQ), (E*SQQ - HQQ)   AND   (HQP - E*SQP)
C                        TERMONE        TERMTWO                TERM3 
 
C     WRITE(IW,*)' in METHOD 4, CURRENT ETUN=',ETUN

      JI=0
      IJ=0
      KJ=0
C     CONVERT HPQ06, SPQ06,HQP06,SQP06,SQQ06,HQQ06 TO VECTORS
      DO 8200 I=1,2
         DO 8201  J=1,(NUMBF-2)
               IJ=(J-1)*2+I
               JI=(I-1)*(NUMBF-2)+J
               HPQ06V(IJ)=HPQ06(I,J)
               ESPQ06V(IJ)=SPQ06(I,J)*ETUN
               HQP06V(JI)=HQP06(J,I)
               ESQP06V(JI)=SQP06(J,I)*ETUN
C              TERMONEV(IJ)=HPQ06(I,J)-ETUN*SPQ06(I,J)
C              TERM3V(JI)=HQP06(J,I)-ETUN*SQP06(J,I)
            DO 8202 K=1,(NUMBF-2)
               KJ=(K-1)*(NUMBF-2)+J
               HQQ06V(KJ)=HQQ06(J,K)
               ESQQ06V(KJ)=SQQ06(J,K)*ETUN
C              TERMTWOV(KJ)=ETUN*SQQ06(J,K)-HQQ06(J,K)               
 8202       CONTINUE
 8201    CONTINUE
 8200 CONTINUE


      CALL VSUB(ESPQ06V,1,HPQ06V,1,TERMONEV,1,(2*NUMBF-4))
      CALL VSUB(ESQP06V,1,HQP06V,1,TERM3V,1,(2*NUMBF-4))
      CALL VSUB(HQQ06V,1,ESQQ06V,1,TERMTWOV,1,((NUMBF-2)*(NUMBF-2)))

C     INVERT TERM 2 (TERMTWO)
      TTDIM=NUMBF-2
      CALL DGETRF(TTDIM,TTDIM,TERMTWOV,TTDIM,IPIV,INFO )
      CALL DGETRI(TTDIM,TERMTWOV,TTDIM,IPIV,SPACE,3*NUMMO0,INFO)


C     MULTIPLICATION OF TERMTWOV AND TERM3
      CALL MRARBR(TERMTWOV,(NUMBF-2),(NUMBF-2),(NUMBF-2),TERM3V,
     *            (NUMBF-2),2,TEMPVEC1,(NUMBF-2))

C     MULTIPLICATION OF FIRST TERM WITH PRODUCT OF 2ND AND 3RD TERMS
      CALL MRARBR(TERMONEV,2,2,(NUMBF-2),TEMPVEC1,
     *            (NUMBF-2),2,TEMPVEC2,2)

 
      HEFFPP(1,1)=HPP06(1,1)+TEMPVEC2(1)
      HEFFPP(1,2)=HPP06(1,2)+TEMPVEC2(3)
      HEFFPP(2,1)=HPP06(2,1)+TEMPVEC2(2)
      HEFFPP(2,2)=HPP06(2,2)+TEMPVEC2(4)
C     WRITE(IW,*) '---------------------------------'
C     WRITE(IW,*)'PRINTING HEFFPP'
C     WRITE(IW,*) '---------------------------------'
C     WRITE(IW,*)HEFFPP(1,1),HEFFPP(1,2)
C     WRITE(IW,*)HEFFPP(2,1),HEFFPP(2,2)

C  TESTING TO CALL GF DYNAMICS EVERY ITERATION
         IF(GFDYNA)THEN
            WRITE(IW,*)'INSIDE GREENF SUBROUTINE, GFDYNA=TRUE'
            HDD=HEFFPP(1,1)
            HDA=HEFFPP(1,2)
            HAD=HEFFPP(2,1)
            HAA=HEFFPP(2,2)
            CALL GFDYNAM(HDD,HDA,HAD,HAA,ETUN)
         ENDIF

C      ---------------------------------------------------------------------
C      FIND THE EIGENVALUES OF HEFFPP
C      AND LOOP TO CONVERGE
C      ---------------------------------------------------------------------
 
C     WRITE(IW,*) '---------------------------------'
C     WRITE(IW,*)'ALGEBRAIC SOLN : EIGENVALUES OF HEFFPP'
C     WRITE(IW,*) '---------------------------------'
  
C     ALGEBRAIC EIGENVALUE SOLUTIONS:
      TRACE=HEFFPP(1,1)+HEFFPP(2,2)
      DETER=HEFFPP(1,1)*HEFFPP(2,2)-HEFFPP(1,2)*HEFFPP(2,1)

C     CHECK TO MAKE SURE NOT IMAGINARY 
      CHECKER=(TRACE*TRACE-(4.0D0*DETER))
      IF(CHECKER.LT.(0.0D0)) THEN
        WRITE(IW,*)'ERROR! EIGENVALUES HAVE BECOME IMAGINARY, EXITING!'
        WRITE(IW,*)'CONVERGENCE OF EFFECTIVE HAMILTONIAN FAILED!'
        IF(SCANDA)  ELECCOU=0.0D0
        GOTO 8320
      ENDIF

C     SOLVE ALGEBRAICALLY FOR EIGENVALUES
      HEFFEIG(1)=(TRACE+DSQRT(TRACE*TRACE-(4.0D0*DETER)) )/2.0D0
      HEFFEIG(2)=(TRACE-DSQRT(TRACE*TRACE-(4.0D0*DETER)) )/2.0D0
C     DO 8310 I=1,2
C         WRITE(IW,*) HEFFEIG(I), 'HEFFEIG(',I,')'
C8310 CONTINUE
 
     
C     COMPARE TO OLD EIGENVALUES (HEFFEIGP=HEFFEIG"PREVIOUS")

      IF(M.GT.0)THEN
         HEIGDIFF(1)=ABS(HEFFEIGP(1)-HEFFEIG(1))
         HEIGDIFF(2)=ABS(HEFFEIGP(2)-HEFFEIG(2))
      ENDIF

C     WRITE(IW,*)'EIGENVALUES:',HEFFEIG(1),HEFFEIG(2),'ETUN',ETUN,
C    *'ITERATION #',M,'HEIGDIFF',HEIGDIFF(1),HEIGDIFF(2)

C     EXIT IF EIGENVALUES CONVERGED

      IF(ABS(HEIGDIFF(1)/HEFFEIGP(1)).LE.0.000001D0.AND.
     *   ABS(HEIGDIFF(2)/HEFFEIGP(2)).LE.0.000001D0)THEN
        WRITE(IW,*)'EIGENVALUES CONVERGED'
        WRITE(IW,*)'IN',M,'ITERATIONS'
        IF(SCANDA)        ELECCOU=HEFFPP(1,2)
        GOTO 8320
      ENDIF

C     IF UNCONVERGED RESET VALUES FOR NEXT ITERATION
      HEFFEIGP(1)=HEFFEIG(1)
      HEFFEIGP(2)=HEFFEIG(2)
C     TESTING EFFECT OF MAKING SMALLER STEPS ON CONVERGENCE:
      IF(NEWETUN.eq.0) ETUN=(HEFFEIG(1)+HEFFEIG(2))/2.0D+00
      IF(NEWETUN.eq.1) THEN 
           ETUN=(((HEFFEIG(1)+HEFFEIG(2))/2.0D+00)+ETUN)/2.0D+00
      ENDIF

C  FOR DIFFICULT CASES:
C  TRY ADDING IN AN IF-LOOP THAT WILL FORCE IT OUT OF AN OSCILLATORY "CONVERGENCE" RUT
C
      RUTSTOP(1)=RUTSTOP(2)
      RUTSTOP(2)=RUTSTOP(3)
      RUTSTOP(3)=RUTSTOP(4)
      RUTSTOP(4)=RUTSTOP(5)
      RUTSTOP(5)=ETUN
C
      IF(ETUN.EQ.RUTSTOP(1).OR.ETUN.EQ.RUTSTOP(2).OR.ETUN.EQ.RUTSTOP(3)
     * .OR.ETUN.EQ.RUTSTOP(4))THEN
C         ETUN=(RUTSTOP(1)+RUTSTOP(2)+RUTSTOP(3)+RUTSTOP(4))/4.0D0
          ETUN=EVEC(DONOR)
          WRITE(IW,*)'WARNING: ACTIVATED RUTSTOP DUE TO CYCLIC  LOOP'
      ENDIF

      IF(M.GE.50)THEN
         WRITE(IW,*)'EXITING: GREATER THAN 50 ITERATIONS'
         WRITE(IW,*)'WARNING: CHARGE TRANSFER CALC NOT CONVERGED'
         IF(NEWETUN.eq.0) THEN
             NEWETUN=1
C            RE-INITIALIZE, AND TRY NEW ETUN-SEARCH METHOD
             WRITE(IW,*)'RESTARTING ITERATIONS, WITH NEW ETUN SEARCH'
             M=0
             HEIGDIFF(1)=1.0D+00
             HEIGDIFF(2)=1.0D+00
             HEFFEIGP(1)=0.0D+00
             HEFFEIGP(2)=0.0D+00
             GOTO 8340 
         ENDIF
C        EXIT ET CALC FULLY, IF ALREADY TRIED OTHER ETUN SEARCH
         IF(NEWETUN.eq.1) THEN
            IF(SCANDA) ELECCOU=0.0D0
         GOTO 8320
         ENDIF
      ENDIF
      M=M+1
        
      GOTO 8340


 8320 CONTINUE

C       ---------------- PRINTING --------------------
        WRITE(IW,8350) DONOR, ACCEPT
 8350 FORMAT(/10X,21('-'),/10X,'PRINTING HEFFPP',/10X,
     *      'FOR DONOR=',I4,1X,'AND ACCEPTOR=',I4,
     *      /10X,21('-'),/)
        IF(M.GE.51) WRITE(IW,*)'WARNING, INCOMPLETE!!!'
        WRITE(IW,*) 'HEFFPP = '
        WRITE(IW,*) HEFFPP(1,1), HEFFPP(1,2)
        WRITE(IW,*) HEFFPP(2,1), HEFFPP(2,2)
        WRITE(IW,*) ' '
C
        WRITE(IW,*) 'TDA, THE ELECTRONIC COUPLING OF D/A = ',HEFFPP(1,2)
        WRITE(IW,*) 'AT A TUNNELING ENERGY, ETUN = ',ETUN
        WRITE(IW,*) 'Hpp Component of Eff. Hamiltonian =',HPP06(1,2)
     
        WRITE(IW,*) ELECCOU,'ELECCOU value at end of greenf'

C
C     IF CALLING GREEN FUNCTION ELECTRON DYNAMICS, CALL NEXT SUBROUTINE
C        IF(GFDYNA)THEN
C           WRITE(IW,*)'INSIDE GREENF SUBROUTINE, GFDYNA=TRUE'
C           HDD=HEFFPP(1,1)
C           HDA=HEFFPP(1,2)
C           HAD=HEFFPP(2,1)
C           HAA=HEFFPP(2,2)
C           CALL GFDYNAM(HDD,HDA,HAD,HAA,ETUN)
C        ENDIF
C     END OF METHOD 4
C     ENDIF



C     GOING HERE FOR RE-STARTING THE GF CALCULATION FOR NEW ETUN
C     METHODS 1-3
  
C     BUILD GREEN FUNCTION MATRIX FOR PATHWAYS ANALYSIS
      IF(METHOD.EQ.1.OR.METHOD.EQ.2.) THEN
        CALL METHOD2(NUM)
      ENDIF
C 


      RETURN
      END
C


C ----------------------------------------------------
C ----------------------------------------------------
C*MODULE CTRANS  *DECK GFDYNAM
      SUBROUTINE GFDYNAM(HDD,HDA,HAD,HAA,ETUN)

      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION ETUN
      INTEGER I
      DOUBLE PRECISION EARRAY(201), GOFE(201)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
 
C     SUBROUTINE TO EXECUTE ELECTRONIC DYNAMIC 'SPECTRUM'
C     FROM EQUATION 2.30 IN "THEORIES OF STRUCTURE-FUNCTION RELATIONSHIPS"
C     BY SKOURTIS, BERATAN 
      DOUBLE PRECISION HDD, HDA, HAD, HAA

C     ZERO OUT EARRAY
      DO 50 I=1,201
         EARRAY(I)=0.0D0
 50   CONTINUE

      WRITE(IW,*)'IN SUBROUTINE GFDYNAM'
      WRITE(IW,*)'--------------ENERGY ARRAY---------------'
      DO 100 I=1,201
        IF(I.LE.100)EARRAY(I)=ETUN-(101.0D0-I)*0.0010D0
        IF(I.EQ.101)EARRAY(I)=ETUN
        IF(I.GE.102)EARRAY(I)=ETUN+(I-101.0D0)*0.0010D0
        WRITE(IW,*)EARRAY(I),'EARRAY(',I,')'
        GOFE(I)=HAD/((EARRAY(I)-HDD)*(EARRAY(I)-HAA)+HAD*HDA)
        WRITE(IW,*)GOFE(I),'GOFE(',I,')'
 100  CONTINUE



      RETURN
      END
 

C ----------------------------------------------------
C-------------------------------------------------------
C*MODULE CTRANS  *DECK INVERTS
      SUBROUTINE INVERTS(AVECTOR,DIM,BVECTOR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)

      INTEGER DIM, IJ
      INTEGER INDEX(DIM)
      DOUBLE PRECISION SCALE(DIM)
      DOUBLE PRECISION AMATRIX(DIM,DIM), BMATRIX(DIM,DIM)
      DOUBLE PRECISION TEMP(DIM,DIM)
      DOUBLE PRECISION AVECTOR(DIM*DIM)
      DOUBLE PRECISION BVECTOR(DIM*DIM)

C     AVECTOR= INPUT VECTOR
C     AMATRIX= INPUT VECTOR CONVERTED TO MATRIX
C     BMATRIX= WORKING INVERTED MATRIX
C     BVECTOR= VECTOR FORM OF INVERTED MATRIX, OUTPUT


C     TESTING IF ALL IS WELL IN THIS SUBROUTINE
C     WRITE(IW,*)'IN SUBROUTINE INVERTS'

      IJ=0
C     INITIALIZE 
      DO 1 I=1,DIM
         SCALE(I)=0.0D0
         DO 2 J=1,DIM
            IJ=(J-1)*DIM+I
            AMATRIX(I,J)=0.0D0
            BMATRIX(I,J)=0.0D0
            TEMP(I,J)=0.0D0
            BVECTOR(IJ)=0.0D0
 2     CONTINUE
 1    CONTINUE

      PJ=0.0D0

C     CONVERT AVECTOR INTO AMATRIX
      DO 10 I=1,DIM
          DO 20 J=1,DIM
             K=(J-1)*DIM+I
             AMATRIX(I,J)=AVECTOR(K)
 20       CONTINUE
 10   CONTINUE


C..................................................................
C     ROUTINE TO INVERT MATRIX A(N,N) WITH THE INVERSE STORED IN X(N,N)
C     IN THE OUTPUT, WITH INDEX() IS PIVOTING ORDER, TEMP() TEMP MATRIX
C     USES THE PARTIAL-PIVOTING GAUSSIAN ELIMINATION METHOD.

C     INVERT  "AMATRIX"
 
C     ROUTINE TO INVERT MATRIX A(N,N) WITH THE INVERSE STORED IN X(N,N)
C     IN THE OUTPUT, WITH INDEX() IS PIVOTING ORDER, TEMP() TEMP MATRIX
C     USES THE PARTIAL-PIVOTING GAUSSIAN ELIMINATION METHOD.
 
C     INITIALIZE TEMPORARY MATRIX TO IDENTITY
      N=DIM
      DO    1000 I = 1, N
        DO  1010 J = 1, N
          TEMP(I,J) = 0.0D0
 1010   CONTINUE
 1000 CONTINUE
      DO    1020 I = 1, N
          TEMP(I,I) = 1.0D0
 1020 CONTINUE
 
C     INITIALIZE INDEX
 
      DO   1030    I = 1, N
        INDEX(I) = I
 1030 CONTINUE
 
C     IDENTIFY RESCALING FACTORS FROM EACH ROW
        DO    1040   I = 1, N
          C1= 0.0D0
          DO  1050   J = 1, N
            C1 = AMAX1(C1,ABS(AMATRIX(I,J)))
 1050     CONTINUE
          SCALE(I) = C1
 1040   CONTINUE
 
C     FIND THE PIVOTING ELEMENT FROM EACH ROW
      DO    1060   J = 1, N-1
        PIVOT1 = 0.0D0
        DO  1070   I = J, N
          PIVOT = ABS(AMATRIX(INDEX(I),J))/SCALE(INDEX(I))
          IF (PIVOT.GT.PIVOT1) THEN
            PIVOT1 = PIVOT
            K   = I
          ELSE
          ENDIF
 1070   CONTINUE
 
C       INTERCHANGE THE ROWS VIA INDEX(N) TO RECORD PIVOTING ORDER
        ITMP    = INDEX(J)
        INDEX(J) = INDEX(K)
        INDEX(K) = ITMP
        DO  1080   I = J+1, N
        PJ  = AMATRIX(INDEX(I),J)/AMATRIX(INDEX(J),J)
 
C       RECORD PIVOTING RATIOS BELOW THE DIAGONAL
          AMATRIX(INDEX(I),J) = PJ
 
C       MODIFY OTHER ELEMENTS ACCORDINGLY
 
         DO 1090   K = J+1, N
          AMATRIX(INDEX(I),K)=AMATRIX(INDEX(I),K)-PJ*AMATRIX(INDEX(J),K)
 1090     CONTINUE
 1080   CONTINUE
 1060 CONTINUE
 
 
      DO 2000 I = 1, N-1
        DO 2010 J = I+1, N
          DO 2020 K = 1, N
            TEMP(INDEX(J),K) = TEMP(INDEX(J),K)
     *                    -AMATRIX(INDEX(J),I)*TEMP(INDEX(I),K)
 2020     CONTINUE
 2010   CONTINUE
 2000 CONTINUE
C
      DO 2030 I = 1, N
        BMATRIX(N,I) = TEMP(INDEX(N),I)/AMATRIX(INDEX(N),N)
        DO  2040 J = N-1, 1, -1
          BMATRIX(J,I) = TEMP(INDEX(J),I)
          DO 2050 K = J+1, N
            BMATRIX(J,I) = BMATRIX(J,I)-AMATRIX(INDEX(J),K)*BMATRIX(K,I)
 2050     CONTINUE
          BMATRIX(J,I) =  BMATRIX(J,I)/AMATRIX(INDEX(J),J)
 2040   CONTINUE
 2030 CONTINUE
C

C     INVERSION COMPLETE

C     CONVERT BMATRIX INTO BVECTOR
      DO 11 I=1,DIM
          DO 12 J=1,DIM
             K=(J-1)*DIM+I
             BVECTOR(K)=BMATRIX(I,J)
C            IF(K.LT.20)WRITE(IW,*)'IN BVECTOR,K',BVECTOR(K),K
 12        CONTINUE
 11    CONTINUE

      RETURN
      END
C



C ----------------------------------------------------
C ----------------------------------------------------
C*MODULE CTRANS  *DECK METHOD2
      SUBROUTINE METHOD2(NUMBF)

      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION SUMME
      INTEGER N,I,J,K,NUMBF, NUMB, NMATD
      INTEGER METHOD, DONOR, ACCEPT, PARTI
 
      PARAMETER (MXATM=3000)
      PARAMETER (NUMMO0=2000, NUMM20=NUMMO0*NUMMO0)  
C     ------------------------------------------------------------
      DIMENSION SVEC(NUMM20), ORBVEC(NUMM20), OLVEC(NUMM20)
      DIMENSION EVEC(NUMMO0), FOCKV(NUMM20)
      DIMENSION FOCKLMO(NUMM20), SLMO(NUMM20)

      DIMENSION TRAN(NUMM20)
      DIMENSION SXMAT(NUMBF,NUMBF), ORBMAT(NUMBF,NUMBF)
      DIMENSION OVERMAT(NUMBF,NUMBF)
      DIMENSION GFMAT(NUMBF,NUMBF)
      DIMENSION GFMATV(NUMBF*NUMBF)

      DIMENSION WRK(8*NUMBF**2)

C     ------------------------------------------------------------
      DIMENSION FOCKPTH(NUMBF*NUMBF)
      DIMENSION SPTH(NUMBF*NUMBF)
      DIMENSION FOCKM(NUMBF,NUMBF)
      DIMENSION GFTEMP(NUMBF,NUMBF)
      DIMENSION GFTEMPV(NUMBF*NUMBF)
      DIMENSION GFMINVV(NUMBF*NUMBF)
      DIMENSION GFMINV(NUMBF,NUMBF)
      DIMENSION GFMONE(NUMBF,NUMBF)
      DIMENSION GFMTWO(NUMBF,NUMBF)

      DIMENSION GFINVV(NUMBF*NUMBF)
      DIMENSION GFINV(NUMBF,NUMBF)
      DIMENSION HEFF(NUMBF,NUMBF), TERM1(NUMBF,NUMBF)
      DIMENSION TERM2A(NUMBF,NUMBF), TERM2(NUMBF,NUMBF)

      LOGICAL CGREEN, PNBO, GFDYNA, VIRTNO, SCANDA,PATHWY,HEFF96,
     *        LMOPTH

      COMMON /GREENS/ SVEC, ORBVEC, EVEC, FOCKV, OLVEC, TRAN
      COMMON /GREEN2/ FOCKLMO,SLMO
      COMMON /GFPAR / CGREEN,PNBO,GFDYNA,VIRTNO,SCANDA,PATHWY,HEFF96,
     *                LMOPTH
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PRPOPT/ ETOLLZ,ILOCAL
 
      COMMON /GFPAR2/ ETUN
      COMMON /GFPAR3/ METHOD, PARTI, DONOR, ACCEPT
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)

 
C     -----------------------------------------------
C     METHOD 2=======================================
C     -----------------------------------------------
C     CALCULATE GF MATRIX WITH EQN 9, BERATAN 1996
C     PROJECTED GREEN'S FUNCTION METHOD
C
C     G(E) = [S * (E*S-H)^-1 * S ]
C     

C     ----------------
C     INITIALIZE NEW MATRICES
C     ----------------
      IJ=0
      DO 210 I=1,NUM
         DO 211 J=1,NUM
            IJ=(J-1)*NUM+I
            FOCKPTH(IJ)=0.0D0
            OVERMAT(I,J)=0.0D0
            FOCKM(I,J)=0.0D0
            GFTEMP(I,J)=0.0D0
            GFTEMPV(IJ)=0.0D0
            GFMINVV(IJ)=0.0D0
            GFMINV(I,J)=0.0D0
            GFMONE(I,J)=0.0D0
            GFMTWO(I,J)=0.0D0
 211     CONTINUE
 210  CONTINUE


C     ---------------------------------
C     PREPARE FOCK, OVERLAP FOR LMO PATHWAYS CASE
      IF(LMOPTH)THEN
          IF(VIRTNO) NMATD=NA
          IF(.NOT.VIRTNO) NMATD=NUM
          WRITE(IW,*) NMATD,'NMATD=LMO Pathways dimension in METHOD2'
          DO 377 I=1,NMATD
             DO 378 J=1,NMATD
                 IJ=(J-1)*NMATD+I
                 FOCKPTH(IJ)=FOCKLMO(IJ)
                 SPTH(IJ)=SLMO(IJ)
 378         CONTINUE
 377      CONTINUE             
C     END OF LMO PATHWAYS
      ENDIF

C     ---------------------------------
C     PREPARE FOR AO PATHWAYS CASE
      IF(.NOT.LMOPTH) THEN
          NMATD=NUM
      WRITE(IW,*) NMATD,'NMATD=AO Pathways dimension in METHOD2'
          DO 379 I=1,NMATD
             DO 388 J=1,NMATD
                 IJ=(J-1)*NMATD+I
                 FOCKPTH(IJ)=FOCKV(IJ)
                 SPTH(IJ)=SVEC(IJ)
 388         CONTINUE
 379      CONTINUE             
C     END OF AO PATHWAYS SETUP
      ENDIF

    
      CALL PRTRI33(FOCKPTH,NMATD)
      CALL PRTRI34(SPTH,NMATD)
 
      IJ=0
C     CONVERT SYMMETRIC MATRICES FROM VECTORS, OVERLAP, FOCK
      DO 243 I=1,NMATD
          DO 244 J=1,I-1
             IJ=IJ+1
             OVERMAT(I,J)=SPTH(IJ)
             OVERMAT(J,I)=SPTH(IJ)
             FOCKM(I,J)=FOCKPTH(IJ)
             FOCKM(J,I)=FOCKPTH(IJ)
 244      CONTINUE
C         FOR I = J, DIAGONAL ENTRIES
          IJ=IJ+1
          OVERMAT(I,I)=SPTH(IJ)
          FOCKM(I,I)=FOCKPTH(IJ)
 243  CONTINUE


C     FIRST COMPUTE THE MIDDLE INVERSE TERM:

      IJ=0
      DO 980 I=1,NMATD
          DO 990 J=1,NMATD
              GFTEMP(I,J)=ETUN*OVERMAT(I,J) - FOCKM(I,J)
                IJ=(J-1)*NMATD+I
                GFTEMPV(IJ)=GFTEMP(I,J)
  990     CONTINUE
  980 CONTINUE


C     INVERT [ES-H] MATRIX, GFTEMP 
      CALL INVERTS(GFTEMPV,NMATD,GFMINVV)
C     PRINT THE INVERTED GFTEMP
C     CALL PRSQ4(GFMINVV,NMATD,NMATD,NMATD)

C     CONVERT GFMINVV INTO MATRIX GFMINV
      IJ=0
      DO 991 I=1,NMATD
          DO 992 J=1,NMATD
                IJ=(J-1)*NMATD+I
                GFMINV(I,J)=GFMINVV(IJ)
  992     CONTINUE
  991 CONTINUE


C     ------------------------------------------------
C     FIRST MULTIPLICATION S*GFMINV 
C
      DO 3010 I=1,NMATD
         DO 3020 J=1,NMATD
            SUMME=0.0D0
            DO 3030 K=1,NMATD
               SUMME=SUMME+OVERMAT(I,K)*GFMINV(K,J)
 3030       CONTINUE
            GFMONE(I,J)=SUMME    
 3020    CONTINUE
 3010 CONTINUE

C     ------------------------------------------------
C     SECOND MULTIPLICATION GFMONE*S 
C
      DO 3040 I=1,NMATD
         DO 3050 J=1,NMATD
            SUMME=0.0D0
            DO 3060 K=1,NMATD
               SUMME=SUMME+GFMONE(I,K)*OVERMAT(K,J)
 3060       CONTINUE
            GFMTWO(I,J)=SUMME    
 3050    CONTINUE
 3040 CONTINUE


C     PRINTING THE GF MATRIX METHOD 2
C
        WRITE(IW,3070)
 3070 FORMAT(/10X,21('-'),/10X,'GREENS FUNCTION MATRIX METHOD 2',
     *      /10X,21('-'),/)
      IF(ILOCAL.EQ.1.OR.ILOCAL.EQ.2.OR.ILOCAL.EQ.3) THEN
         IF(LMOPTH)THEN
         WRITE(IW,*)'---------IN LMO BASIS -----------'
         ENDIF
      ENDIF
        IMAX = 0
 3080   IMIN = IMAX+1
        IMAX = IMIN+5
        IF (IMAX .GT. NMATD) IMAX = NMATD
        WRITE(IW,3090) (J,J=IMIN,IMAX)
        DO 4000 I = 1,NMATD
          WRITE(IW,4010) I,(GFMTWO(I,J),J=IMIN,IMAX)
 4000   CONTINUE
        WRITE(IW,*)
        IF (IMAX .LT. NMATD)THEN
            WRITE(IW,*)
            GO TO 3080
        ENDIF
 3090   FORMAT(5X,6I12)
 4010   FORMAT(1X,I4,6F12.8)
C
C





C     ------------------------------------------------
C     ------------------------------------------------
C     CALCULATION OF EFFECTIVE HAMILTONIAN HEFF
      IF(HEFF96)THEN
C
C     FORMULATION IN NONORTHOGONAL BASIS SET:
C     FROM: I.V. KURNIKOV, D.N. BERATAN. J. CHEM. PHYS. VOL.105, NO.21, 1996.
C
C
C     CONVERT GFMAT TO VECTOR FOR INVERSION
      IJ=0
      DO 10 I=1,NUMBF
        DO 20 J=1,NUMBF
           IJ=(J-1)*NUMBF+I
           GFMATV(IJ)=GFMAT(I,J)
 20     CONTINUE
 10     CONTINUE

C     INVERT THE GREEN FUNCTION MATRIX
      CALL INVERTS(GFMATV,NUMBF,GFINVV)

      IJ=0
      DO 30 I=1,NUMBF
         DO 40 J=1,NUMBF
            IJ=(J-1)*NUMBF+I
            GFINV(I,J)=GFINVV(IJ)
 40      CONTINUE
 30   CONTINUE

C
C     ----------------------------------------------------------
C          HEFF(E)= E * SPP - SPP * (GPP(E))^-1 * SPP 
C     ----------------------------------------------------------
C  
      DO 370 I=1,NUMBF
          DO 380 J=1,NUMBF
              TERM1(I,J)=ETUN*OVERMAT(I,J)
  380     CONTINUE
  370 CONTINUE  
C

C     OVERMAT*GFINV CALCULATION AS FIRST PART OF SECOND TERM:
C
      DO 390 I=1,NUMBF
          DO 400 J=1,NUMBF
              SUMME=0.0D0
              DO 410 N=1,NUMBF
                  SUMME=SUMME+OVERMAT(I,N)*GFINV(N,J)
  410         CONTINUE
              TERM2A(I,J)=SUMME
  400     CONTINUE
  390 CONTINUE
C
C     (OVERMAT*GFINV)*OVERMAT SECOND PART OF SECOND TERM MULTIPLICATION
C
      DO 420 I=1,NUMBF
          DO 430 J=1,NUMBF
              SUMME=0.0D0
              DO 440 N=1,NUMBF
                  SUMME=SUMME+TERM2A(I,N)*OVERMAT(N,J)
  440         CONTINUE
              TERM2(I,J)=SUMME
  430     CONTINUE
  420 CONTINUE
C
C
C     TEST-PRINTING TERM2
C
C       WRITE(IW,820)
C 820 FORMAT(/10X,21('-'),/10X,'TERM2',
C    *      /10X,21('-'),/)
C       IMAX = 0
C 845   IMIN = IMAX+1
C       IMAX = IMIN+5
C       IF (IMAX .GT. NUMBF) IMAX = NUMBF
C       WRITE(IW,850) (J,J=IMIN,IMAX)
C       DO 830 I = 1,NUMBF
C         WRITE(IW,860) I,(TERM2(I,J),J=IMIN,IMAX)
C 830   CONTINUE
C       WRITE(IW,*)
C       IF (IMAX .LT. NUMBF)THEN
C           WRITE(IW,*)
C           GO TO 845
C       ENDIF
C 850   FORMAT(5X,6I12)
C 860   FORMAT(1X,I4,6F12.8)
C
C
C
      DO 450 I=1,NUMBF
          DO 460 J=1,NUMBF
              HEFF(I,J)=TERM1(I,J)-TERM2(I,J)
  460     CONTINUE
  450 CONTINUE
C
C     PRINTING THE EFFECTIVE HAMILTONIAN, HEFF
C
        WRITE(IW,470)
  470 FORMAT(/10X,21('-'),/10X,'EFFECTIVE HAMILTONIAN',
     *      /10X,21('-'),/)
        IMAX = 0
  480   IMIN = IMAX+1
        IMAX = IMIN+5
        IF (IMAX .GT. NUMBF) IMAX = NUMBF
        WRITE(IW,490) (J,J=IMIN,IMAX)
        DO 500 I = 1,NUMBF
          WRITE(IW,510) I,(HEFF(I,J),J=IMIN,IMAX)
  500   CONTINUE
        WRITE(IW,*)
        IF (IMAX .LT. NUMBF)THEN
            WRITE(IW,*)
            GO TO 480
        ENDIF
  490   FORMAT(5X,6I12)
  510   FORMAT(1X,I4,6F12.8)
C
C
C     END OF METHOD 1,2 HEFF CALC
      ENDIF
C
 

      RETURN
      END
 
C----------------------------------------------------------
C----------------------------------------------------------




C ----------------------------------------------------
C ----------------------------------------------------
C*MODULE CTRANS  *DECK METHOD3
      SUBROUTINE METHOD3(NUMBF)

      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION SUMME
      INTEGER N,I,J,K,NUMBF, NUMB
      INTEGER METHOD, PARTI, DONOR, ACCEPT
 
      PARAMETER (MXATM=3000)
      PARAMETER (NUMMO0=2000, NUMM20=NUMMO0*NUMMO0)  
C     ------------------------------------------------------------
      DIMENSION SVEC(NUMM20), ORBVEC(NUMM20), OLVEC(NUMM20)
      DIMENSION EVEC(NUMMO0), FOCKV(NUMM20)
      DIMENSION TRAN(NUMM20)
      DIMENSION ORBMAT(NUMBF,NUMBF)
      DIMENSION OVERMAT(NUMBF,NUMBF)
      DIMENSION SINVERS(NUMBF,NUMBF)
      DIMENSION SINVERSV(NUMBF*NUMBF)
      DIMENSION FOCKLMO(NUMBF**2)
      DIMENSION SLMO(NUMBF**2)
      DIMENSION WRK(8*NUMBF**2)
      DIMENSION FOCKM(NUMBF,NUMBF)

C     ------------------------------------------------------------
C     PARTITIONS OF MATRICES

      DIMENSION HBAR(NUMBF,NUMBF)
      DIMENSION HBARPP(PARTI,PARTI)
      DIMENSION HBARQQ(NUMBF-PARTI,NUMBF-PARTI)
      DIMENSION HBARPQ(PARTI,NUMBF-PARTI)
      DIMENSION HBARQP(NUMBF-PARTI,PARTI)

 
      DIMENSION HBARP2(NUMBF,NUMBF)
      DIMENSION SPP(PARTI,PARTI), STEMP(NUMBF,NUMBF)
      DIMENSION STEMPV(NUMBF*NUMBF)
      DIMENSION SINVPP(PARTI,PARTI)
      DIMENSION SINVQQ(NUMBF-PARTI,NUMBF-PARTI)
      DIMENSION SINVPQ(PARTI,NUMBF-PARTI)
      DIMENSION SINVQP(NUMBF-PARTI,PARTI)

C     METHOD 3
      DIMENSION CMATRIX(PARTI,NUMBF-PARTI)
      DIMENSION DMATRIX(NUMBF-PARTI,NUMBF-PARTI)
      DIMENSION DMATRIXV((NUMBF-PARTI)*(NUMBF-PARTI))
      DIMENSION FMATRIX(NUMBF-PARTI,PARTI)
      DIMENSION DMATINVV((NUMBF-PARTI)*(NUMBF-PARTI))
      DIMENSION DMATINV(NUMBF-PARTI,NUMBF-PARTI)
      DIMENSION RTERM2(NUMBF-PARTI,PARTI)
      DIMENSION RPP(PARTI,PARTI)
      DIMENSION ATERM2(PARTI,PARTI)
      DIMENSION ATERM(PARTI,PARTI)
      DIMENSION BTERM2(PARTI,PARTI)
      DIMENSION BTERM(PARTI,PARTI)
C    
      DIMENSION DELTAPP(PARTI,PARTI)
C     DIMENSION GPP(PARTI,PARTI)
C     DIMENSION GPPV(PARTI*PARTI)
      DIMENSION GPREINV(PARTI,PARTI)

C    GPP VIA EQUATION 64
      DIMENSION GPP64(PARTI,PARTI)
      DIMENSION GPP64M(PARTI,PARTI)
      DIMENSION GPP64MI(PARTI,PARTI)
      DIMENSION GPP64MIV(PARTI*PARTI)
      DIMENSION GPP64B(PARTI,PARTI)
      DIMENSION GPREINVV(PARTI*PARTI)
      DIMENSION GPP64MV(PARTI*PARTI)
 
C    DIAGONALIZATION OF DELTAPP
      DIMENSION DIAGSCR(8*NUMBF), DPPEIG(NUMBF),DPPEVEC(NUMBF*NUMBF)
      DIMENSION DPPWRK(NUMBF)
      DIMENSION DPPVEC((NUMBF*NUMBF)/2+NUMBF/2)

      LOGICAL NITERAT

      COMMON /GREENS/ SVEC, ORBVEC, EVEC, FOCKV, OLVEC, TRAN
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PRPOPT/ ETOLLZ,ILOCAL
 
      COMMON /GFPAR2/ ETUN
      COMMON /GFPAR3/ METHOD, PARTI, DONOR, ACCEPT
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)

C     -----------------------------------------

      IF(ILOCAL.EQ.1.OR.ILOCAL.EQ.2.OR.ILOCAL.EQ.3) THEN

C     IF EXCLUDING THE VIRTUAL ORBITALS FROM THE CALCULATION
C     THEN SKIP TO SECTION TREATING THE ALTERED MATRIX DIMENSIONS

C       PRODUCE TRANSFORMED FOCK MATRIX
        CALL TFTRI(FOCKLMO,FOCKV,OLVEC,WRK,NUMBF,NUMBF,NUMBF)
C       CALL PRTRI5(FOCKLMO,NUMBF)

C       PRODUCE TRANSFORMED OVERLAP MATRIX
        CALL TFTRI(SLMO,SVEC,OLVEC,WRK,NUMBF,NUMBF,NUMBF)
C       CALL PRTRI2(SLMO,NUMBF)


      ENDIF


C     -----------------------------------------
C     CONVERT MO, S, FOCK VECTORS TO MATRICES
 
      IJ=0
C     CONVERT SYMMETRIC MATRICES FROM VECTORS, OVERLAP, FOCK
      DO 334 I=1,NUMBF
          DO 335 J=1,I-1
             IJ=IJ+1
             OVERMAT(I,J)=SLMO(IJ)
             OVERMAT(J,I)=SLMO(IJ)
             FOCKM(I,J)=FOCKLMO(IJ)
             FOCKM(J,I)=FOCKLMO(IJ)
 335      CONTINUE
C         FOR I = J, DIAGONAL ENTRIES
          IJ=IJ+1
          OVERMAT(I,I)=SLMO(IJ)
          FOCKM(I,I)=FOCKLMO(IJ)

C     CONVERT NONSYMMETRIC MATRICES FROM VECTORS: EIGENVECTORS
          IJ2=0
          NUMB=NUMBF
          DO 336 J=1,NUMB
             IJ2=(J-1)*NUMBF+I
C          IF(ILOCAL.EQ.1.OR.ILOCAL.EQ.2.OR.ILOCAL.EQ.3) THEN
C            ORBMAT(I,J)=OLVEC(IJ2)
C          ELSE
C            ORBMAT(I,J)=ORBVEC(IJ2)
C          ENDIF
 336      CONTINUE
 334  CONTINUE




C     ------------------------------------------------
C     METHOD 3========================================
C     SIMILAR TO METHOD 4 EXCEPT THAT IT PARTITIONS INTO 
C     BLOCKS OF DONOR-ACCEPTOR SPACE, PARTITIONING THE D/A
C     SPACE OF DIMENSION "PARTI" APART FROM THE REST OF THE
C     SPACE OF DIMENSION "NUMBF"
C     ------------------------------------------------
C
C     METHOD THREE, SECTION IV.C OF:
C     PRIYADARSHY ET AL J. CHEM. PHYS VOL 104, NO. 23, 15 JUNE 1996
C     
C     DELTAPP(E) = EFFECTIVE HAMILTONIAN, HEFF
C
C     HEFF(E) = -E * ( A ) + ( B )
C     FOR  A  = ( SPP * (S^-1)PP * SPP - SPP )
C          B  = ( SPP * RPP(E) * SPP )
C     FOR RPP = HBARPP + ( C ) * ( D ) * ( F )
C          C  = HBARPQ - E * (S^-1)PQ 
C          D  = [ E * (S^-1)QQ  - HBARQQ  ]^-1
C          F  = HBARQP -  E * (S^-1)QP
C     FOR HBAR= (S^-1)* H* (S^-1)
C        THEN PARTITIONING HBAR AFTERWARDS (OTHERWISE MULTIPLICATION DIMN ARE OFF!)
C
C     SO CALCULATING EACH OF THESE COMPONENTS....
C
C     FIRST MUST PARTITION THE MATRICES
C     RECORD PARTITIONING SCHEME (A-D GROUP AND BRIDGE)
C     FROM USER-INPUT, ATOM-SELECTION ARRAY "PARTI"
C     ...... FOR NOW WILL START WITH ASSUMING JUST FIRST X ATOMS
C     LATER, ONCE ALLOWING USER TO INPUT AN ARRAY OF ATOMS:
C     PIVOT ROWS AND COLUMNS TO REORDER MATRICES INTO 
C     A-D AND BRIDGE PARTITIONS
C
C     FOR NOW, ASSUME IT'S ALREADY IN ORDER FOR PARTITIONING, WITH
C     PARTI=NUMBER OF BASIS FUNCTIONS INVOLVED IN THE D-A PARTITION.
C     (COULD LATER CHANGE THIS TO BEING THE ATOMS, THEN CALCULATE 
C      HOW MANY BF'S THIS WOULD IMPLY)
C

C     ------------------------------------------------------------
C     CHANGE TUNNELING ENERGY PARAMETER TO AVERAGE OF
C     HOMO AND LUMO ENERGIES, IF NO ETUN KEYWORD ENTERED

      NUMMO=NA
C     IF (ETUN.EQ.3333) THEN
          ETUN=(EVEC(NUMMO)+EVEC(NUMMO+1))/2.0D0
          WRITE(IW,*)'CALCULATED HOMO-LUMO ENERGY AVERAGE FOR ETUN'
          NITERAT=.TRUE.
C     ENDIF

C     ------------------------------------------------------------


C     CREATE PP PARTITION OF UNINVERTED OVERLAP MATRIX
      DO 8040 I=1,PARTI
        DO 8041 J=1,PARTI
             SPP(I,J)=OVERMAT(I,J)
 8041   CONTINUE
 8040 CONTINUE
C     MAKE A COPY OF OVERMAT TO USE IN THE INVERSION SO IT DOESN'T CORRUPT
      DO 127 I=1,NUMBF
         DO 128 J=1,NUMBF
            STEMP(I,J)=OVERMAT(I,J)
 128     CONTINUE
 127  CONTINUE
 
C     ------------------------
C     INVERT OVERLAP MATRIX 1X
C     ------------------------
      IJ=0
      DO 6010 I=1,NUMBF
        DO 6020 J=1,NUMBF
           IJ=(J-1)*NUMBF+I
           STEMPV(IJ)=STEMP(I,J)
 6020 CONTINUE
 6010 CONTINUE

C     STEMP INTO SINVERS
      CALL INVERTS(STEMPV,NUMBF,SINVERSV)

      IJ=0
      DO 6030 I=1,NUMBF
         DO 6040 J=1,NUMBF
            IJ=(J-1)*NUMBF+I
            SINVERS(I,J)=SINVERSV(IJ)
 6040    CONTINUE
 6030 CONTINUE

C     PARTITION THE OVERLAP MATRIX INVERSE, SINVXX
C
      DO 7070 I=1,PARTI
        DO 7071 J=1,PARTI
             SINVPP(I,J)=SINVERS(I,J)
 7071 CONTINUE
 7070 CONTINUE
      DO 7072 I=(PARTI+1),NUMBF
        DO 7073 J=(PARTI+1),NUMBF
             SINVQQ((I-PARTI),(J-PARTI))=SINVERS(I,J)
 7073 CONTINUE
 7072 CONTINUE
      DO 7074 I=1,PARTI
        DO 7075 J=(PARTI+1),NUMBF
             SINVPQ(I,(J-PARTI))=SINVERS(I,J)
 7075 CONTINUE
 7074 CONTINUE
      DO 7076 I=(PARTI+1),NUMBF
        DO 7077 J=1,PARTI
             SINVQP((I-PARTI),J)=SINVERS(I,J)
 7077 CONTINUE
 7076 CONTINUE

C---------------------------------------------------
C
C     FOR HBAR = (S^-1) * H * (S^-1)
C     FOR H= FOCKM
C     THEN PARTITION HBAR AFTER THIS MULTIPLICATION
      DO 5000 I=1,NUMBF
         DO 5001 J=1,NUMBF
            SUMME=0.0D0
            DO 5002 K=1,NUMBF
               SUMME=SUMME+FOCKM(I,K)*SINVERS(K,J)
 5002       CONTINUE
            HBARP2(I,J)=SUMME
 5001    CONTINUE
 5000 CONTINUE
      DO 5003 I=1,NUMBF
         DO 5004 J=1,NUMBF
            SUMME=0.0D0
            DO 5005 K=1,NUMBF
               SUMME=SUMME+SINVERS(I,K)*HBARP2(K,J)
 5005       CONTINUE
            HBAR(I,J)=SUMME
 5004    CONTINUE
 5003 CONTINUE

C     PARTITON THE HBAR MATRIX

      DO 5010 I=1,PARTI
        DO 5020 J=1,PARTI
             HBARPP(I,J)=HBAR(I,J)
 5020 CONTINUE
 5010 CONTINUE
      DO 5030 I=(PARTI+1),NUMBF
        DO 5040 J=(PARTI+1),NUMBF
             HBARQQ((I-PARTI),(J-PARTI))=HBAR(I,J)
 5040 CONTINUE
 5030 CONTINUE
      DO 5050 I=1,PARTI
        DO 5060 J=(PARTI+1),NUMBF
             HBARPQ(I,(J-PARTI))=HBAR(I,J)
 5060 CONTINUE
 5050 CONTINUE
      DO 5070 I=(PARTI+1),NUMBF
        DO 5080 J=1,PARTI
             HBARQP((I-PARTI),J)=HBAR(I,J)
 5080 CONTINUE
 5070 CONTINUE

C --- CHECKED, IT'S WORKING!
C     TEST-PRINT
C     DO 5090 I=1,PARTI
C       DO 5091 J=1,(NUMBF-PARTI)
C            WRITE(IW,*)'HBARPQ',HBARPQ(I,J),'ENTRY',I,',',J
C5091 CONTINUE
C5090 CONTINUE

C     CARRY-OUT MATRIX MULTIPLICATIONS FROM PARTITIONED MATRICES

C     FOR RPP = HBARPP + ( C ) * ( D )^-1 * ( F )
C          CMATRIX  = HBARPQ - E * (S^-1)PQ
C          DMATRIX  = E * (S^-1)QQ  - HBARQQ
C          FMATRIX  = HBARQP -  E * (S^-1)QP

      DO 8000 I=1,(NUMBF-PARTI)
         DO 8001 J=1,PARTI
            FMATRIX(I,J)=HBARQP(I,J) - ETUN*SINVQP(I,J)
            CMATRIX(J,I)=HBARPQ(J,I) - ETUN*SINVPQ(J,I)
 8001    CONTINUE
         DO 8002 K=1,(NUMBF-PARTI)
            DMATRIX(I,K)=ETUN*SINVQQ(I,K) - HBARQQ(I,K)
 8002    CONTINUE
 8000 CONTINUE

C     INVERT DMATRIX TO DMATINV
C     ------------------------
      N=NUMBF-PARTI
      IJ=0
      DO 8010 I=1,NUMBF
        DO 8020 J=1,NUMBF
           IJ=(J-1)*NUMBF+I
           DMATRIXV(IJ)=DMATRIX(I,J)
 8020 CONTINUE
 8010 CONTINUE

      CALL INVERTS(DMATRIXV,N,DMATINVV)

      IJ=0
      DO 8021 I=1,NUMBF
        DO 8022 J=1,NUMBF
           IJ=(J-1)*NUMBF+I
           DMATINV(I,J)=DMATINVV(IJ)
 8022 CONTINUE
 8021 CONTINUE

C     CARRY-OUT MATRIX MULTIPLICATIONS FROM PARTITIONED MATRICES
C     FOR RPP = HBARPP + ( C ) * ( D )^-1 * ( F )
      
      DO 8030 I=1,NUMBF-PARTI
         DO 8031 J=1,PARTI
            SUMME=0.0D0
            DO 8032 K=1,NUMBF-PARTI
               SUMME=SUMME+DMATINV(I,K)*FMATRIX(K,J)
 8032       CONTINUE
               RTERM2(I,J)=SUMME
 8031    CONTINUE
 8030 CONTINUE
C
      DO 8033 I=1,PARTI
         DO 8034 J=1,PARTI
            SUMME=0.0D0
            DO 8035 K=1,NUMBF-PARTI
               SUMME=SUMME+CMATRIX(I,K)*RTERM2(K,J)
 8035       CONTINUE
               RPP(I,J)= HBARPP(I,J) + SUMME
 8034    CONTINUE
 8033 CONTINUE
C
C     TEST-PRINT
C     DO 5090 I=1,PARTI
C       DO 5091 J=1,PARTI
C            WRITE(IW,*)'RPP',RPP(I,J),'ENTRY',I,',',J
C5091 CONTINUE
C5090 CONTINUE

C     ----------------------------------------------------------------------
C     CALCULATE COMPONENTS FOR THE DELTAPP(E) = EFFECTIVE HAMILTONIAN, HEFF
C
C     DELTAPP(E) = -E * ( A ) + ( B )
C     FOR  A  = ( SPP * (S^-1)PP * SPP - SPP )
C          B  = ( SPP * RPP(E) * SPP )

C SPP HAS A WRONG VALUE FOR THE 6-2 /2-6 CORRELATION
C    CALCULATE COMPONENT "B"
      DO 8042 I=1,PARTI
         DO 8043 J=1,PARTI
            SUMME=0.0D0
            DO 8044 K=1,PARTI
               SUMME=SUMME+RPP(I,K)*SPP(K,J)
 8044       CONTINUE
               BTERM2(I,J)=SUMME
 8043    CONTINUE
 8042 CONTINUE

C   ERROR CONTROL
C       WRITE(IW,8036)
C8036 FORMAT(/10X,21('-'),/10X,'ERROR CONTROL , SPP',
C    *      /10X,21('-'),/)
C       IMAX = 0
C8037   IMIN = IMAX+1
C       IMAX = IMIN+5
C       IF (IMAX .GT. PARTI) IMAX = PARTI
C       WRITE(IW,8038) (J,J=IMIN,IMAX)
C       DO 8039 I = 1,PARTI
C         WRITE(IW,8055) I,(SPP(I,J),J=IMIN,IMAX)
C8039   CONTINUE
C       WRITE(IW,*)
C       IF (IMAX .LT. PARTI)THEN
C           WRITE(IW,*)
C           GO TO 8037
C       ENDIF
C8038   FORMAT(5X,6I12)
C8055   FORMAT(1X,I4,6F12.8)

      DO 8045 I=1,PARTI
         DO 8046 J=1,PARTI
            SUMME=0.0D0
            DO 8047 K=1,PARTI
               SUMME=SUMME+SPP(I,K)*BTERM2(K,J)
 8047       CONTINUE
            BTERM(I,J)=SUMME
 8046    CONTINUE
 8045 CONTINUE

C    CALCULATE COMPONENT "A"
      DO 8048 I=1,PARTI
         DO 8049 J=1,PARTI
            SUMME=0.0D0
            DO 8050 K=1,PARTI
               SUMME=SUMME+SINVPP(I,K)*SPP(K,J)
 8050       CONTINUE
               ATERM2(I,J)=SUMME
 8049    CONTINUE
 8048 CONTINUE
      DO 8051 I=1,PARTI
         DO 8052 J=1,PARTI
            SUMME=0.0D0
            DO 8053 K=1,PARTI
               SUMME=SUMME+SPP(I,K)*ATERM2(K,J)
 8053       CONTINUE
               ATERM(I,J)=SUMME - SPP(I,J)
 8052    CONTINUE
 8051 CONTINUE

C     COMPUTE DELTAPP(E) 
C     (EFFECTIVE HAMILTONIAN IN PARTITIONED GF APPROXIMATION)

      DO 8060 I=1,PARTI
        DO 8061 J=1,PARTI
             DELTAPP(I,J)=(-1)*ETUN*ATERM(I,J)+BTERM(I,J)
 8061   CONTINUE
 8060 CONTINUE

C     TEST-PRINT
C     DO 5090 I=1,PARTI
C       DO 5091 J=1,PARTI
C            WRITE(IW,*)'DELTAPP',DELTAPP(I,J),'ENTRY',I,',',J
C5091 CONTINUE
C5090 CONTINUE

C    -------------------------------------
C    ALSO COMPUTE THE GF MATRIX UNDER THIS FORMULATION FOR PATH INFO
C    USING EUQATION #50 FROM J. CHEM PHYS 104 (23) 15 JUNE 1996, P9479
C    GPP(E)=( ETUN*[S^-1]PP - RPP(E) )^-1
C    -------------------------------------

      DO 8070 I=1,PARTI
         DO 8071 J=1,PARTI
C           SET UP EQUATION 50 TO GET INVERTED:
            GPREINV(I,J)= ETUN*SINVPP(I,J) - RPP(I,J)
C           SET UP MIDDLE TERM OF GPP EQN 64 TO GET INVERTED:
            GPP64M(I,J)= ETUN*SPP(I,J) - DELTAPP(I,J)
C      WRITE(IW,*)'GPREINV(I,J)',GPREINV(I,J),'FOR (I,J)',I,',',J
 8071 CONTINUE
 8070 CONTINUE


C     INVERT GPREINV INTO GPP 

      IJ=0
      DO 1352 I=1,PARTI 
         DO 1353 J=1,PARTI
            IJ=(J-1)*PARTI+I
C           GPREINVV(IJ)=GPREINV(I,J)
            GPP64MV(IJ)=GPP64M(I,J)
 1353 CONTINUE
 1352 CONTINUE

C     CALL INVERTS(GPREINVV,PARTI,GPPV)

C     IJ=0
C     DO 1354 I=1,PARTI
C        DO 1355 J=1,PARTI
C           IJ=(J-1)*PARTI+I
C           GPP(I,J)=GPPV(IJ)
C1355 CONTINUE
C1354 CONTINUE

C     USING SECTION IN METHOD 2 TO COMPUTE INVERSE

C     INVERT GPP64M TO GPP64MI

      CALL INVERTS(GPP64MV,PARTI,GPP64MIV)

      IJ=0
      DO 1356 I=1,PARTI
         DO 1357 J=1,PARTI
            IJ=(J-1)*PARTI+I
            GPP64MI(I,J)=GPP64MIV(IJ)
 1357 CONTINUE
 1356 CONTINUE
C 
C     ROUTINE TO INVERT MATRIX A(N,N) WITH THE INVERSE STORED IN X(N,N)
C     IN THE OUTPUT, WITH INDEX() IS PIVOTING ORDER, TEMP() TEMP MATRIX
C     USES THE PARTIAL-PIVOTING GAUSSIAN ELIMINATION METHOD.
C
C     INITIALIZE TEMPORARY MATRIX TO IDENTITY
C     CHANGE DIMENSION FOR USING METHOD 3
C     N=PARTI

C     DO    8115 I = 1, N
C       DO    8116 J = 1, N
C         TEMP(I,J) = 0.0
C8116   CONTINUE
C8115 CONTINUE
C     DO    8117 I = 1, N
C         TEMP(I,I) = 1.0
C8117 CONTINUE
C 
C     INITIALIZE INDEX
C 
C     DO   8118    I = 1, N
C       INDEX(I) = I
C8118 CONTINUE
C
C     IDENTIFY RESCALING FACTORS FROM EACH ROW
C
C       DO    8119   I = 1, N
C         C1= 0.0
C         DO  8120   J = 1, N
C           IF(METHOD.EQ.3) C1 = AMAX1(C1,ABS(GPP64M(I,J)))
C8120     CONTINUE
C         SCALE(I) = C1
C         WRITE(IW,*) SCALE(I)
C8119   CONTINUE
C       WRITE(IW,*)''
C
C     FIND THE PIVOTING ELEMENT FROM EACH ROW
C
C     DO    8121   J = 1, N-1
C       PIVOT1 = 0.0
C       DO  8122   I = J, N
C            PIVOT = ABS(GPP64M(INDEX(I),J))/SCALE(INDEX(I))
C         IF (PIVOT.GT.PIVOT1) THEN
C           PIVOT1 = PIVOT
C           K   = I
C         ELSE
C         ENDIF
C8122   CONTINUE
C
C INTERCHANGE THE ROWS VIA INDEX(N) TO RECORD PIVOTING ORDER
C
C       ITMP    =INDEX(J)
C       INDEX(J) =INDEX(K)
C       INDEX(K) =ITMP
C       DO  8123   I=J+1,N
C         PJ=GPP64M(INDEX(I),J)/GPP64M(INDEX(J),J)
C
C RECORD PIVOTING RATIOS BELOW THE DIAGONAL
C
C         GPP64M(INDEX(I),J)=PJ
C
C MODIFY OTHER ELEMENTS ACCORDINGLY
C
C         DO 8124  K=J+1,N
C      GPP64M(INDEX(I),K)=GPP64M(INDEX(I),K)-PJ*GPP64M(INDEX(J),K)
C8124     CONTINUE
C8123   CONTINUE
C8121 CONTINUE
C
C
C     DO    8125 I=1,N-1
C       DO  8126 J=I+1,N
C         DO 8127 K=1,N
C           TEMP(INDEX(J),K)=TEMP(INDEX(J),K)
C    *                    -GPP64M(INDEX(J),I)*TEMP(INDEX(I),K)
C8127     CONTINUE
C8126   CONTINUE
C8125 CONTINUE
C
C     DO    8128 I = 1, N
C       GPP64MI(N,I)=TEMP(INDEX(N),I)/GPP64M(INDEX(N),N)
C       DO 8129 J = N-1, 1, -1
C         GPP64MI(J,I) = TEMP(INDEX(J),I)
C         DO 8130 K = J+1, N
C           GPP64MI(J,I) = GPP64MI(J,I)-GPP64M(INDEX(J),K)*GPP64MI(K,I)
C8130     CONTINUE
C         GPP64MI(J,I) =  GPP64MI(J,I)/GPP64M(INDEX(J),J)
C8129   CONTINUE
C8128 CONTINUE
C
C     PRINTING
C       WRITE(IW,8131)
C8131 FORMAT(/10X,21('-'),/10X,'GPP64MI',
C    *      /10X,21('-'),/)
C       IMAX = 0
C8132   IMIN = IMAX+1
C       IMAX = IMIN+5
C       IF(METHOD.NE.3)THEN
C       IF (IMAX .GT. NUMBF) IMAX = NUMBF
C       ELSE
C       IF (IMAX .GT. PARTI) IMAX = PARTI
C       ENDIF
C       WRITE(IW,8133) (J,J=IMIN,IMAX)
C       DO 8134 I = 1,PARTI
C         WRITE(IW,8135) I,(GPP64MI(I,J),J=IMIN,IMAX)
C8134   CONTINUE
C       WRITE(IW,*)
C       IF (IMAX .LT. PARTI)THEN
C           WRITE(IW,*)
C           GO TO 8132
C       ENDIF
C8133   FORMAT(5X,6I12)
C8135   FORMAT(1X,I4,6F12.8)
C
C------------- INVERSE GPP64MI DONE

C COMPLETE GPP EQN 64
      DO 8090 I=1,PARTI
         DO 8091 J=1,PARTI
            SUMME=0.0D0
            DO 8092 K=1,PARTI
               SUMME=SUMME+GPP64MI(I,K)*SPP(K,J) 
 8092       CONTINUE
            GPP64B(I,J)=SUMME
 8091    CONTINUE
 8090 CONTINUE

      DO 8093 I=1,PARTI
         DO 8094 J=1,PARTI
            SUMME=0.0D0
            DO 8095 K=1,PARTI
               SUMME=SUMME+SPP(I,K)*GPP64B(K,J)
 8095       CONTINUE
            GPP64(I,J)=SUMME
 8094    CONTINUE
 8093 CONTINUE
C
C     PRINTING GPP EQUATION 64
C
        WRITE(IW,8096)
 8096 FORMAT(/10X,21('-'),/10X,'PRINTING GPP64 GREEN FUNCTION',
     *      /10X,21('-'),/)
        IMAX = 0
 8097   IMIN = IMAX+1
        IMAX = IMIN+5
        IF (IMAX .GT. PARTI) IMAX=PARTI
        WRITE(IW,8098) (J,J=IMIN,IMAX)
        DO 8099 I = 1,PARTI
          WRITE(IW,8100) I,(GPP64(I,J),J=IMIN,IMAX)
 8099   CONTINUE
        WRITE(IW,*)
        IF (IMAX .LT.PARTI)THEN
            WRITE(IW,*)
            GO TO 8097
        ENDIF
 8098   FORMAT(5X,6I12)
 8100   FORMAT(1X,I4,6F12.8)

C
C     PRINTING MORE THINGS
C
        WRITE(IW,7061)
 7061 FORMAT(/10X,21('-'),/10X,'PRINTING EFFECTIVE HAM., DELTAPP',
     *      /10X,21('-'),/)
        IMAX = 0
 7062   IMIN = IMAX+1
        IMAX = IMIN+5
        IF (IMAX .GT. PARTI) IMAX =PARTI
        WRITE(IW,7063) (J,J=IMIN,IMAX)
        DO 7065 I = 1,PARTI
          WRITE(IW,7064) I,(DELTAPP(I,J),J=IMIN,IMAX)
 7065   CONTINUE
        WRITE(IW,*)
        IF (IMAX .LT.PARTI)THEN
            WRITE(IW,*)
            GO TO 7062
        ENDIF
 7063   FORMAT(5X,6I12)
 7064   FORMAT(1X,I4,6F12.8)

C      ---------------------------------------------------------------------
C      DIAGONALIZE DELTAPP AND HARVESTING THE EIGENVALUES
C           NEED TO CONVERGE ETUN, TO SOME FUNCTION OF THE EVALUES
C      ---------------------------------------------------------------------
C WILL NEED TO ADD TO MY COMMON STATEMENTS:
C      DIAGSCR(NUMBF,8) ? NEEDED TO ADD OR DOES GLDIAG DEFINE THIS?
C      EIGENVALUE OUTPUT
C      EIGENVECTOR OUTPUT
C      DIAGERR?
C      
C     NEED TO CHANGE DELTAPP INTO A VECTOR, I THINK A LOWER TRIANGLE...
      IJ=0
      DO 8138 I=1,PARTI
          DO 8139 J=1,I-1
             IJ=IJ+1
             DPPVEC(IJ)=DELTAPP(I,J)
             WRITE(IW,*)IJ,' ',DPPVEC(IJ),'DPPVEC AT IJ'
 8139     CONTINUE
C         FOR I = J, DIAGONAL ENTRIES
          IJ=IJ+1
          DPPVEC(IJ)=DELTAPP(I,I)
           WRITE(IW,*)IJ,' ',DPPVEC(IJ),'DPPVEC AT IJ'
 8138 CONTINUE


      CALL GLDIAG(PARTI,PARTI,PARTI,DPPVEC,DIAGSCR,
     *            DPPEIG,DPPEVEC,DELERR,DPPWRK)
C
      WRITE(IW,*) '---------------------------------'
      WRITE(IW,*)'AFTER GLDIAG, PRINTING DPPEIG(N)'
      WRITE(IW,*) '---------------------------------'
      DO 8140 I=1,PARTI
          WRITE(IW,*) DPPEIG(I), 'DPPEIG(',I,')'
 8140 CONTINUE
C
      IF(NITERAT)GOTO 8151
C
C      FOR NOW AVERAGE THE EIGENVALUES, AND SET THIS AS THE NEW ETUN FOR ITERATION
      SUMME=0.0D0
      DO 8145 I=1,PARTI
         SUMME=SUMME+DPPEIG(I)
 8145 CONTINUE
      ETUNNEW=SUMME/PARTI
      WRITE(IW,*)'UPDATED ETUN AVERATE, ETUNNEW=',ETUNNEW

C     COMPARE ETUNNEW TO ETUN AND IF OUT OF THE TOLERANCE
C        RETURN TO BEGINNING, AND RE-CALCULATE ALL THE MATRICES
C        AND CONTINUE ITERATING UNTIL REACHES THE TOLERANCE
      IF(ETUN.GE.ETUNNEW) THEN
        ETUNDIF=ETUN-ETUNNEW
      ELSE 
        ETUNDIF=ETUNNEW-ETUN
      ENDIF
      IF(ETUNDIF.LE.0.0037D0) THEN
       WRITE(IW,*)'ETUN CONVERGED TO WITHIN 0.01 HARTREE'
       WRITE(IW,*)'ETUN VALUE',ETUN
       GOTO 8151
      ENDIF
      ETUN=ETUNNEW
      WRITE(IW,*)'RE-ENTERING THE GF CALCULATION LOOP'
      WRITE(IW,*)'ETUNNEW VALUE',ETUNNEW
 8151 CONTINUE

C     END OF METHOD 3
      RETURN
      END
C----------------------------------------------------------
C----------------------------------------------------------



C ----------------------------------------------------
C ----------------------------------------------------
C
C*MODULE MTHLIB  *DECK PRSQ1
      SUBROUTINE PRSQ1(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,5555)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 5555 FORMAT(/10X,31('-'),/10X,'SLOCAL: OVERLAP*TRANSFORMATION ORBTRA',
     *       /10X,31('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C
C*MODULE MTHLIB  *DECK PRSQ2
      SUBROUTINE PRSQ2(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,4555)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 4555 FORMAT(/10X,21('-'),/10X,'FOCK BEFORE TRANSFORMATION IN ORBTRA',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C
C*MODULE MTHLIB  *DECK PRSQ3
      SUBROUTINE PRSQ3(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'TRANSFORMATION MAT, ORBMAT^-1*OLMAT',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C
C*MODULE MTHLIB  *DECK PRSQ4
      SUBROUTINE PRSQ4(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'GFTEMP MATRIX IN METHOD 2',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C
C*MODULE MTHLIB  *DECK PRSQ5
      SUBROUTINE PRSQ5(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'FLOCAL TRANSFORMED IN ORBTRA',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C
C*MODULE MTHLIB  *DECK PRSQ6
      SUBROUTINE PRSQ6(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'OVERLAP MATRIX AT START',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END

C
C*MODULE MTHLIB  *DECK PRSQ7
      SUBROUTINE PRSQ7(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'SLOCALV IN GREENF AFTER REWRITE',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C
C*MODULE MTHLIB  *DECK PRSQ8
      SUBROUTINE PRSQ8(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008) 
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'FOCK MATRIX IN AO BASIS',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END

C*MODULE MTHLIB  *DECK PRSQ9
      SUBROUTINE PRSQ9(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C     
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'TRANORB, MRARBR OF MO(CAN)*TRAN, ',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END

C*MODULE MTHLIB  *DECK PRSQ10
      SUBROUTINE PRSQ10(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C     
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'OUTPUT, TFSQU T-DAG * MO(CAN) * T, ',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END


C*MODULE MTHLIB  *DECK PRSQ11
      SUBROUTINE PRSQ11(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C     
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'TRAN, NOW INSIDE SUBROUTINE GREENF ',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END



C*MODULE MTHLIB  *DECK PRSQ12
      SUBROUTINE PRSQ12(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'TRAN, INSIDE SUBROUTINE PRGREN ',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END



C*MODULE MTHLIB  *DECK PRSQ13
      SUBROUTINE PRSQ13(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'empty for now.....',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END

C*MODULE MTHLIB  *DECK PRSQ14
      SUBROUTINE PRSQ14(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'VECIN, before tran in local.src',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END


C*MODULE MTHLIB  *DECK PRSQ15
      SUBROUTINE PRSQ15(V,M,N,NDIM)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,2060)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN,IMAX)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) J,(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,', LOCALIZED ORBITALS WITH VIRTNO',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END

C*MODULE MTHLIB  *DECK PRSQ16
      SUBROUTINE PRSQ16(V,M,N,NDIM,NFROZ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION V(NDIM,M)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT OUT A SQUARE MATRIX -----
C     -V- IS -N- ROWS BY -M- COLUMNS, WITH LEADING DIMENSION -NDIM-
C
      WRITE(IW,2060)
      WRITE(IW,2061)

      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      IMAX = 0
  100 IMIN = IMAX+1
      IMAX = IMAX+MAX
      IF (IMAX .GT. M) IMAX = M
      WRITE (IW,9008)
      WRITE (IW,9028) (I,I = IMIN+NFROZ,IMAX+NFROZ)
      WRITE (IW,9008)
      DO 120 J = 1,N
  120 WRITE (IW,9048) (J+NFROZ),(V(J,I),I = IMIN,IMAX)
      IF (IMAX .LT. M) GO TO 100
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,' DAMATRIX FOR SCANDA OPTION',
     *      /10X,21('-'),/)
 2061 FORMAT(/10X,'ROWS=ACCEPTOR LMOS COLUMNS=DONOR LMOS',/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END



C*MODULE MTHLIB  *DECK PRTRI1
      SUBROUTINE PRTRI1(D,N)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION D(*)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT SYMMETRIC MATRIX -D- OF DIMENSION -N- -----
C
      WRITE(IW,2060)
      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      MM1 = MAX-1
      DO 120 I0=1,N,MAX
         IL = MIN(N,I0+MM1)
         WRITE(IW,9008)
         WRITE(IW,9028) (I,I=I0,IL)
         WRITE(IW,9008)
         IL = -1
         DO 100 I=I0,N
            IL=IL+1
            J0=I0+(I*I-I)/2
            JL=J0+MIN(IL,MM1)
            WRITE(IW,9048) I,(D(J),J=J0,JL)
  100    CONTINUE
  120 CONTINUE
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'FOCK MATRIX IN AO BASIS',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C

C*MODULE MTHLIB  *DECK PRTRI2
      SUBROUTINE PRTRI2(D,N)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION D(*)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT SYMMETRIC MATRIX -D- OF DIMENSION -N- -----
C
      WRITE(IW,2060)
      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      MM1 = MAX-1
      DO 120 I0=1,N,MAX
         IL = MIN(N,I0+MM1)
         WRITE(IW,9008)
         WRITE(IW,9028) (I,I=I0,IL)
         WRITE(IW,9008)
         IL = -1
         DO 100 I=I0,N
            IL=IL+1
            J0=I0+(I*I-I)/2
            JL=J0+MIN(IL,MM1)
            WRITE(IW,9048) I,(D(J),J=J0,JL)
  100    CONTINUE
  120 CONTINUE
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'OVERLAP IN LMO, L-DAGGER * SAO * L',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C
C*MODULE MTHLIB  *DECK PRTRI3
      SUBROUTINE PRTRI3(D,N)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION D(*)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT SYMMETRIC MATRIX -D- OF DIMENSION -N- -----
C
      WRITE(IW,2060)
      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      MM1 = MAX-1
      DO 120 I0=1,N,MAX
         IL = MIN(N,I0+MM1)
         WRITE(IW,9008)
         WRITE(IW,9028) (I,I=I0,IL)
         WRITE(IW,9008)
         IL = -1
         DO 100 I=I0,N
            IL=IL+1
            J0=I0+(I*I-I)/2
            JL=J0+MIN(IL,MM1)
            WRITE(IW,9048) I,(D(J),J=J0,JL)
  100    CONTINUE
  120 CONTINUE
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'FOCK IN MO BASIS, C-DAG*FOCKAO*C',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C


C*MODULE MTHLIB  *DECK PRTRI4
      SUBROUTINE PRTRI4(D,N)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION D(*)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT SYMMETRIC MATRIX -D- OF DIMENSION -N- -----
C
      WRITE(IW,2060)
      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      MM1 = MAX-1
      DO 120 I0=1,N,MAX
         IL = MIN(N,I0+MM1)
         WRITE(IW,9008)
         WRITE(IW,9028) (I,I=I0,IL)
         WRITE(IW,9008)
         IL = -1
         DO 100 I=I0,N
            IL=IL+1
            J0=I0+(I*I-I)/2
            JL=J0+MIN(IL,MM1)
            WRITE(IW,9048) I,(D(J),J=J0,JL)
  100    CONTINUE
  120 CONTINUE
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'FOCK IN LMO BASIS, TRAN-DIAG*F*TRAN',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C





C*MODULE MTHLIB  *DECK PRTRI5
      SUBROUTINE PRTRI5(D,N)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION D(*)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT SYMMETRIC MATRIX -D- OF DIMENSION -N- -----
C
      WRITE(IW,2060)
      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      MM1 = MAX-1
      DO 120 I0=1,N,MAX
         IL = MIN(N,I0+MM1)
         WRITE(IW,9008)
         WRITE(IW,9028) (I,I=I0,IL)
         WRITE(IW,9008)
         IL = -1
         DO 100 I=I0,N
            IL=IL+1
            J0=I0+(I*I-I)/2
            JL=J0+MIN(IL,MM1)
            WRITE(IW,9048) I,(D(J),J=J0,JL)
  100    CONTINUE
  120 CONTINUE
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'FOCK IN LMO BASIS, L-DAGGER*FMO*L',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C


C*MODULE MTHLIB  *DECK PRTRI6
      SUBROUTINE PRTRI6(D,N)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION D(*)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT SYMMETRIC MATRIX -D- OF DIMENSION -N- -----
C
      WRITE(IW,2060)
      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      MM1 = MAX-1
      DO 120 I0=1,N,MAX
         IL = MIN(N,I0+MM1)
         WRITE(IW,9008)
         WRITE(IW,9028) (I,I=I0,IL)
         WRITE(IW,9008)
         IL = -1
         DO 100 I=I0,N
            IL=IL+1
            J0=I0+(I*I-I)/2
            JL=J0+MIN(IL,MM1)
            WRITE(IW,9048) I,(D(J),J=J0,JL)
  100    CONTINUE
  120 CONTINUE
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'RESULT OF TRAN-DAG*SAO*TRAN',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C
  
  
C*MODULE MTHLIB  *DECK PRTRI7
      SUBROUTINE PRTRI7(D,N)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION D(*)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C     
C     ----- PRINT SYMMETRIC MATRIX -D- OF DIMENSION -N- -----
C
      WRITE(IW,2060)
      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      MM1 = MAX-1
      DO 120 I0=1,N,MAX
         IL = MIN(N,I0+MM1)
         WRITE(IW,9008) 
         WRITE(IW,9028) (I,I=I0,IL)
         WRITE(IW,9008)
         IL = -1
         DO 100 I=I0,N
            IL=IL+1
            J0=I0+(I*I-I)/2
            JL=J0+MIN(IL,MM1)
            WRITE(IW,9048) I,(D(J),J=J0,JL)
  100    CONTINUE
  120 CONTINUE
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'DONOR-ACCEPTOR SCAN, DAMATRIX',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C


C*MODULE MTHLIB  *DECK PRTRI33
      SUBROUTINE PRTRI33(D,N)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION D(*)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT SYMMETRIC MATRIX -D- OF DIMENSION -N- -----
C
      WRITE(IW,2060)
      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      MM1 = MAX-1
      DO 120 I0=1,N,MAX
         IL = MIN(N,I0+MM1)
         WRITE(IW,9008)
         WRITE(IW,9028) (I,I=I0,IL)
         WRITE(IW,9008)
         IL = -1
         DO 100 I=I0,N
            IL=IL+1
            J0=I0+(I*I-I)/2
            JL=J0+MIN(IL,MM1)
            WRITE(IW,9048) I,(D(J),J=J0,JL)
  100    CONTINUE
  120 CONTINUE
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'FOCK MATRIX IN METHOD2',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END
C

C*MODULE MTHLIB  *DECK PRTRI34
      SUBROUTINE PRTRI34(D,N)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION D(*)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     ----- PRINT SYMMETRIC MATRIX -D- OF DIMENSION -N- -----
C
      WRITE(IW,2060)
      IF (MASWRK) THEN
      MAX = 5
      IF (NPRINT .EQ. 6) MAX = 10
      MM1 = MAX-1
      DO 120 I0=1,N,MAX
         IL = MIN(N,I0+MM1)
         WRITE(IW,9008)
         WRITE(IW,9028) (I,I=I0,IL)
         WRITE(IW,9008)
         IL = -1
         DO 100 I=I0,N
            IL=IL+1
            J0=I0+(I*I-I)/2
            JL=J0+MIN(IL,MM1)
            WRITE(IW,9048) I,(D(J),J=J0,JL)
  100    CONTINUE
  120 CONTINUE
      END IF
      RETURN
 2060 FORMAT(/10X,21('-'),/10X,'OVERLAP MATRIX IN METHOD2',
     *      /10X,21('-'),/)
 9008 FORMAT(1X)
 9028 FORMAT(6X,10(4X,I4,4X))
 9048 FORMAT(I5,1X,10F12.7)
      END



C     ...END OF NEW ECOUPLING ROUTINE CODE
C     ============================================
C     ============================================
C     ============================================
                                                                  

